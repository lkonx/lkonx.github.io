<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>MySQL数据库(二) —— 数据类型</title>
    <link href="/2020/10/07/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93(%E4%BA%8C)/"/>
    <url>/2020/10/07/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93(%E4%BA%8C)/</url>
    
    <content type="html"><![CDATA[<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="整型类型"><a href="#整型类型" class="headerlink" title="整型类型"></a>整型类型</h2><p><strong>专门用来保存整数的</strong></p><pre><code class="hljs angelscript">TINYINT         <span class="hljs-number">1</span> 字节  (<span class="hljs-number">-128</span>，<span class="hljs-number">127</span>)(<span class="hljs-number">0</span>，<span class="hljs-number">255</span>)小整数值SMALLINT        <span class="hljs-number">2</span> 字节  (<span class="hljs-number">-32</span> <span class="hljs-number">768</span>，<span class="hljs-number">32</span> <span class="hljs-number">767</span>)(<span class="hljs-number">0</span>，<span class="hljs-number">65</span> <span class="hljs-number">535</span>)大整数值MEDIUMINT       <span class="hljs-number">3</span> 字节  (<span class="hljs-number">-8</span> <span class="hljs-number">388</span> <span class="hljs-number">608</span>，<span class="hljs-number">8</span> <span class="hljs-number">388</span> <span class="hljs-number">607</span>)(<span class="hljs-number">0</span>，<span class="hljs-number">16</span> <span class="hljs-number">777</span> <span class="hljs-number">215</span>)大整数值INT或INTEGER    <span class="hljs-number">4</span> 字节  (<span class="hljs-number">-2</span> <span class="hljs-number">147</span> <span class="hljs-number">483</span> <span class="hljs-number">648</span>，<span class="hljs-number">2</span> <span class="hljs-number">147</span> <span class="hljs-number">483</span> <span class="hljs-number">647</span>)(<span class="hljs-number">0</span>，<span class="hljs-number">4</span> <span class="hljs-number">294</span> <span class="hljs-number">967</span> <span class="hljs-number">295</span>)大整数值BIGINT          <span class="hljs-number">8</span> 字节  (<span class="hljs-number">-9</span>,<span class="hljs-number">223</span>,<span class="hljs-number">372</span>,<span class="hljs-number">036</span>,<span class="hljs-number">854</span>,<span class="hljs-number">775</span>,<span class="hljs-number">808</span>，<span class="hljs-number">9</span> <span class="hljs-number">223</span> <span class="hljs-number">372</span> <span class="hljs-number">036</span> <span class="hljs-number">854</span> <span class="hljs-number">775</span> <span class="hljs-number">807</span>)(<span class="hljs-number">0</span>，<span class="hljs-number">18</span> <span class="hljs-number">446</span> <span class="hljs-number">744</span> <span class="hljs-number">073</span> <span class="hljs-number">709</span> <span class="hljs-number">551</span> <span class="hljs-number">615</span>)极大整数值</code></pre><p><strong>注意点:</strong></p><p>MySQL中的整型区分有符号和无符号，默认情况下整型就是有符号的，我们可以在数据类型的后面加上unsigned来将数据类型变成无符号的</p><pre><code>create table person2(    id int,    age tinyint unsigned);insert into person values (1, -128); #报错insert into person values (1, 127);insert into person values (1, 128);</code></pre><p>在保存数据的时候, 如果超出了当前数据类型的范围, 那么就会报错</p><pre><code>create table person(    id int,    age tinyint);insert into person values (1, -128);insert into person values (1, 127);insert into person values (1, 128); #报错</code></pre><p>在设置整型的时候, 还可以设置整型数据将来显示的位宽</p><pre><code>create table person3(    id int,    age tinyint(2) zerofill);insert into person values (1, 1);   #01insert into person values (1, 12);  #12insert into person values (1, 123); #123</code></pre><h2 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h2><p><strong>专门用来保存小数的</strong></p><pre><code class="hljs reasonml"><span class="hljs-constructor">FLOAT(<span class="hljs-params">m</span>, <span class="hljs-params">d</span>)</span>     <span class="hljs-number">4</span> 字节  单精度<span class="hljs-constructor">DOUBLE(<span class="hljs-params">m</span>, <span class="hljs-params">d</span>)</span>    <span class="hljs-number">8</span> 字节  双精度m总位数, d小数位数</code></pre><p><strong>注意点：float和double的区别</strong><br>占用存储空间大小不一样</p><p>默认保留的小数位数不同</p><pre><code>create table person(    id int,    weight FLOAT,    height DOUBLE);insert into person values (1, 1.12345678901234567890, 1.12345678901234567890);weight: 1.12346height: 1.1234567890123457</code></pre><p>保存数据的有效精度也不同</p><pre><code>create table person3(    id int,    weight FLOAT(20, 19),    height DOUBLE(20, 19));insert into person3 values (1, 1.12345678901234567890, 1.12345678901234567890);weight: 1.123456-8357467651000height: 1.123456789012345-7000</code></pre><p><strong>注意点：</strong><br>浮点类型是不准确的，所以在企业开发中千万不要使用浮点数来保存用户的准确(珍贵)信息(RMB)</p><h2 id="定点类型"><a href="#定点类型" class="headerlink" title="定点类型"></a>定点类型</h2><p><strong>也是用于存储小数的</strong></p><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">decimal</span><span class="hljs-params">(M, D)</span></span>m总位数, d小数位数</code></pre><p><strong>注意点：</strong><br><strong>定点类型的本质: 是将数据分为两个部分来存储,每个部分都是整数所以定点数不要滥用, 因为非常消耗资源</strong></p><pre><code>create table person4(    id int,    weight decimal(21, 20),    height decimal(21, 20));insert into person4 values (1, 1.12345678901234567890, 1.12345678901234567890);weight: 1.12345678901234567890height: 1.12345678901234567890</code></pre><h2 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h2><p><strong>专门用来存储字符的</strong></p><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">CHAR</span><span class="hljs-params">(size)</span></span>    <span class="hljs-number">0</span>-<span class="hljs-number">255</span>   字节    定长字符串<span class="hljs-function"><span class="hljs-title">VARCHAR</span><span class="hljs-params">(size)</span></span> <span class="hljs-number">0</span>-<span class="hljs-number">65535</span> 字节    变长字符串</code></pre><p><strong>注意点：</strong><br> char和varchar能够保存数据的容量不一样，char不会回收多余的字符,  要多少给多少<br> ，varchar会回收多余的字符, 用多少给多少</p><pre><code>通过    char(2)存储存储数据&#39;a&#39;, 存储的结果是&#39; a&#39;通过 varchar(2)存储存储数据&#39;a&#39;, 存储的结果是&#39;a&#39;</code></pre><p><strong>char超出设定范围会报错</strong></p><pre><code>create table person(    id int,    name1 char(2),    name2 varchar(2));insert into person values (1, &#39;a&#39;, &#39;b&#39;);insert into person values (1, &#39;12&#39;, &#39;34&#39;);insert into person values (1, &#39;abc&#39;, &#39;def&#39;); #只要超出申请的范围就会报错</code></pre><p><strong>注意点: 由于是字符类型, 所以传递值建议用单引号’’</strong><br><strong>注意点: VARCHAR理论上可以存储65535个字符, 但是实际会随着当前数据库的字符集改变</strong></p><pre><code>create table person3(    id int,    name1 char(255),    name2 varchar(65535))charset=utf8;Column length too big for column &#39;name2&#39; (max = 21845); use BLOB or TEXT instead65535 / 3 = 21845, 由于utf8一个字符占用3个字节, 所以varchar在utf8的表中最多只能存储21845个字符create table person3(    id int,    name1 char(255),    name2 varchar(65535))charset=gbk;Column length too big for column &#39;name2&#39; (max = 32767); use BLOB or TEXT instead65535 / 2 = 32767, 由于gbk一个字符占用2个字节,所以varchar在gbk的表中最多只能存储32767个字符</code></pre><p><strong>注意点: VARCHAR理论上可以存储65535个字符, 但是实际会随着当前数据库的字符集改变</strong></p><pre><code>65535 / 3 = 21845, 由于utf8一个字符占用3个字节,所以varchar在utf8的表中最多只能存储21845个字符65535 / 2 = 32767, 由于gbk一个字符占用2个字节,所以varchar在gbk的表中最多只能存储32767个字符</code></pre><p><strong>注意点: VARCHAR理论上可以存储65535个字符,但是实际会随着当前数据库的字符集改变</strong></p><h3 id="大文本类型"><a href="#大文本类型" class="headerlink" title="大文本类型"></a>大文本类型</h3><p><strong>MySQL中每一行存储的数据是有大小限制的, 每一行最多只能存储65534个字节</strong></p><pre><code>create table person(    #name1 char(3),    name2 varchar(21844) #在UTF8中相当于65535个字节)charset=utf8;# Row size too large. The maximum row size for the used table type, not counting BLOBs, is 65535. This includes storage overhead, check the manual. You have to change some columns to TEXT or BLOBs</code></pre><p><strong>使用大文本类型解决这个问题</strong></p><pre><code class="hljs angelscript">TINYTEXT   <span class="hljs-number">0</span><span class="hljs-number">-255</span>字节           短文本字符串TEXT       <span class="hljs-number">0</span><span class="hljs-number">-65535</span>字节         长文本数据MEDIUMTEXT <span class="hljs-number">0</span><span class="hljs-number">-16777215</span>字节      中等长度文本数据LONGTEXT   <span class="hljs-number">0</span><span class="hljs-number">-4294967295</span>字节    极大文本数据</code></pre><pre><code> create table person2(    name1 char(3),    name2 TEXT #不会报错, 因为没有超出显示, 实际只占用10个字节)charset=utf8;</code></pre><p><strong>注意点:<br>大文本类型在表中并不会实际占用所能保存的字节数,而是利用10个字节引用了实际保存数据的地址</strong></p><h2 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h2><p><strong>如果某个字段的取值只能是几个固定值中的一个,那么就可以使用枚举</strong></p><pre><code class="hljs crystal"><span class="hljs-class"><span class="hljs-keyword">enum</span>(值1, 值2, ...);</span></code></pre><pre><code>create table person(    id int,    gender enum(&#39;男&#39;, &#39;女&#39;, &#39;妖&#39;));insert into person values (1, &#39;火&#39;); #会报错insert into person values (1, &#39;男&#39;); #不会报错insert into person values (2, &#39;女&#39;); #不会报错insert into person values (3, &#39;妖&#39;); #不会报错</code></pre><p><strong>注意点:</strong></p><p>MySQL中的枚举类型底层都是使用整型来实现的,和其它编程语言不太一样的是,其它编程语言的枚举都是从0开始的, 而MySQL的枚举是从1开始的</p><p>由于MySQL的枚举底层是使用整型实现的,所以我们在赋值的时候除了可以赋值固定的几个值其中的一个意外我们还可以赋值对应的整数</p><pre><code>insert into person values (4, 1); #不会报错insert into person values (4, 4); #会报错</code></pre><h2 id="集合类型"><a href="#集合类型" class="headerlink" title="集合类型"></a>集合类型</h2><p><strong>如果某个字段的取值只能是几个固定值中的几个,那么就可以使用集合类型</strong></p><pre><code class="hljs routeros"><span class="hljs-builtin-name">set</span>(值1, 值2, <span class="hljs-built_in">..</span>.)</code></pre><pre><code>create table person(    id int,    hobby set(&#39;篮球&#39;,&#39;足球&#39;,&#39;高尔夫球&#39;,&#39;足浴&#39;));insert into person values (1, &#39;篮球,足球,高尔夫球&#39;); #不会报错insert into person values (1, &#39;橄榄球&#39;);  #会报错insert into person values (2, &#39;篮球&#39;); #不会报错  1insert into person values (3, &#39;足球&#39;); #不会报错  2insert into person values (4, &#39;高尔夫球&#39;); #不会报错  4insert into person values (5, &#39;足浴&#39;); #不会报错  8</code></pre><p><strong>注意点:MySQL的集合类型也是使用整型来实现的,MySQL的集合类型是按照2(n)的方式来实现的</strong></p><pre><code>2(0) = 12(1) = 22(2) = 42(3) = 8</code></pre><h2 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h2><p><strong>专门用来保存真假的</strong></p><pre><code>create table person(    id int,    flag boolean);insert into person values (1, &#39;男&#39;); #会报错insert into person values (1, true); #不会报错insert into person values (2, false); #不会报错</code></pre><p><strong>注意点:MySQL中的布尔类型也是使用整型来实现的,0就表示假,1就表示真底层的本质是因为MySQL是使用C/C++来实现的, 所以就是’非零即真’</strong></p><pre><code>insert into person values (3, 1); #不会报错insert into person values (4, 0); #不会报错insert into person values (5, 2); #不会报错</code></pre><h2 id="日期类型"><a href="#日期类型" class="headerlink" title="日期类型"></a>日期类型</h2><p><strong>专门用来保存时间的</strong></p><pre><code class="hljs css"><span class="hljs-selector-tag">DATE</span>       3字节   <span class="hljs-selector-tag">YYYY-MM-DD</span>          日期值<span class="hljs-selector-tag">TIME</span>       3字节   <span class="hljs-selector-tag">HH</span><span class="hljs-selector-pseudo">:MM</span><span class="hljs-selector-pseudo">:SS</span>            时间值或持续时间<span class="hljs-selector-tag">DATETIME</span>   8字节   <span class="hljs-selector-tag">YYYY-MM-DD</span> <span class="hljs-selector-tag">HH</span><span class="hljs-selector-pseudo">:MM</span><span class="hljs-selector-pseudo">:SS</span> 混合日期和时间值</code></pre><p><strong>注意点: 在存储时间的时候, 需要用单引号将时间括起来</strong></p><pre><code>create table person(    id int,    filed1 DATE,    filed2 TIME,    filed3 DATETIME);insert into person values (1, &#39;2020-02-02&#39;, &#39;14:18:23&#39;, &#39;2020-02-02 14:18:23&#39;);</code></pre>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《写作这回事》摘抄与感悟</title>
    <link href="/2020/10/05/%E3%80%8A%E5%86%99%E4%BD%9C%E8%BF%99%E5%9B%9E%E4%BA%8B%E3%80%8B%E6%91%98%E6%8A%84%E4%B8%8E%E6%84%9F%E6%82%9F/"/>
    <url>/2020/10/05/%E3%80%8A%E5%86%99%E4%BD%9C%E8%BF%99%E5%9B%9E%E4%BA%8B%E3%80%8B%E6%91%98%E6%8A%84%E4%B8%8E%E6%84%9F%E6%82%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="摘抄"><a href="#摘抄" class="headerlink" title="摘抄"></a>摘抄</h1><ul><li><p>”你写故事时，是在给自己讲故事，“ 他说，” 你修改时，主要工作就是拿掉不属于故事的内容“</p></li><li><p>我学到的最重要的一点就是，作家对角色的最初认识可能和读者一样是错误的。我紧接着又认识到，仅仅因为创作困难，不论是感情上的原因，还是因为想象力缺乏，就中途放弃一部作品，这样的做法不可取。人有时候就得硬着头皮上，哪怕力不从心，仿佛坐着铲屎，使不上劲。因为你干出来的活儿会可能还不错</p></li><li><p>开始是这样：把你的书桌摆到屋角，每次做下去开始写作时，都要提醒自己为什么不把书桌摆在房间正中。生活并非艺术创作的支撑，反之才对。</p></li><li><p>我的建议就是，你为了尽最大的能力写作，有必要建造自己的工具箱，然后增强肌肉力量，才有力气把箱子带在身边。你这样做，就不必在面对艰难任务时感到气馁，而是一把抓过适用的工具，立刻投入工作。</p></li><li><p>记住用词的第一条规矩是使用你想到的第一个词，只要这个词事宜并且生动即可。</p></li><li><p>界定对话做好的方式就是”某某说“。比如”他说“，”她说“，”比尔说“，”莫妮卡说“。</p></li><li><p>你也许已经可以把故事讲得很不错，相信读者看到”他说“就会知道他讲话的语气与动作——是慢是块，是愉快还是伤心。但你的读者也许还在沼泽里挣扎，甭管怎么说，扔给他一根绳索……但绝对没必要拿根九十英尺的钢索把他迎头打晕。</p></li><li><p>概括性句子打头，描述和支持性词句紧跟在后。这种结构要求作者必须理清思路，而且这种结构可以使作者避免游离主题</p></li><li><p>写小说越多，就越会发现，段落是自动形成的。你需要的正是这种效果。写作小说时，最好不必过多考虑何时另起一段。诀窍就是顺其自然</p></li><li><p>我坚持认为段落而非句子才是写作的基本单位——意思在段落中连贯起来，词语有了更多的意义，不再仅仅是单词。段落也体现了节奏的快慢。</p></li><li><p>你如果想成为作家，必须首先得做到两件事：多读，多写。据我所知别无捷径，哪个作家都干过这两件事。</p></li><li><p>糅和不同风格，是你形成个人风格之前的必经阶段，但杂糅不是凭空发生的。你必须广泛阅读。</p></li><li><p>天赋使得练习这回事完全失去了意义；你如果发现自己在做某件事上天赋异禀，会主动去做这件事（不管是什么事）</p></li><li><p>在我看来，短篇小说也罢长篇小说也罢，都是由三部分构成的：叙事，将故事从A点推至B点最终推至Z点，故事结束；描写，把读者带进现场；对话，通过具体言语赋予人物生命。</p></li><li><p>好描写始于所见清晰，终于落笔清晰，意象清新，词汇简单。</p></li><li><p>好小说的注重法则之一就是，你如果可以将某事表现出来，让读者看到，就绝不要明讲出来。</p></li><li><p>从问题主题思想开始写作，几乎注定写不出好小说。好小说总是从故事开始，发展出主题；从主题发展出而来的好故事很少。</p></li><li><p>你如果是为了快乐而做事，就可以永远做下去。</p></li></ul><h1 id="作者推荐书单"><a href="#作者推荐书单" class="headerlink" title="作者推荐书单"></a>作者推荐书单</h1><p>彼得•亚伯拉汉斯：《完美犯罪》</p><p>彼得•亚伯拉汉斯：《熄灯》</p><p>彼得•亚伯拉汉斯：《压降》（又译《窃子疑云》）</p><p>彼得•亚伯拉汉斯：《9号革命》</p><p>詹姆斯•阿奇：《家人亡故》</p><p>克斯滕•巴奇斯：《怪物狗的生活》</p><p>帕特•巴克：《新生》</p><p>帕特•巴克：《门上的眼睛》</p><p>帕特•巴克：《幽灵路》</p><p>理查德•博氏：《黑夜季节》</p><p>彼得•布朗纳：《入侵者》</p><p>保罗•博尔斯：《遮蔽的天空》</p><p>柯拉盖森•波尔：《玉米饼幕布》</p><p>比尔•布莱森：《林中散步》</p><p>克里斯多夫•巴克利：《感谢您吸烟》</p><p>雷蒙德•卡佛：《我打电话的地方》</p><p>迈克尔•查本：《狼人年轻时》</p><p>温莎•乔尔顿：《零纬度》</p><p>迈克尔•康纳利：《诗人》</p><p>约瑟夫•康拉德：《黑暗的心脏》</p><p>K.C. 康斯坦丁：《家庭观念》</p><p>唐•德里罗：《地下世界》</p><p>尼尔森•德米尔：《教堂》</p><p>尼尔森•德米尔：《黄金海岸》</p><p>查尔斯•狄更斯：《雾都孤儿》</p><p>斯蒂芬•道宾斯：《等闲杀戮》</p><p>斯蒂芬•道宾斯：《死女孩的教堂》</p><p>罗迪•道伊尔：《撞上门的女人》</p><p>斯丹利•埃尔金：《迪克•吉布森秀》</p><p>威廉•福克纳：《我弥留之际》</p><p>亚历克斯•嘉兰：《海滩》</p><p>伊丽莎白•乔治：《心怀鬼胎》</p><p>苔丝•格里森：《重力》</p><p>威廉•戈尔丁：《蝇王》</p><p>穆雷尔•格雷：《熔炉》</p><p>格雷厄姆•格林：《一支出卖的枪》</p><p>格雷厄姆•格林：《我们在哈瓦那的人》</p><p>大卫•哈尔伯斯坦姆：《五十年代》</p><p>彼得•哈米尔：《辛纳特拉何以重要》</p><p>托马斯•哈里斯：《汉尼拔》</p><p>肯特•哈鲁夫：《单声颂歌》</p><p>彼得•霍格：《冰雪迷案》</p><p>斯蒂芬•亨特：《白人坏小子》</p><p>大卫•伊格纳修斯：《开火伤人》</p><p>约翰•欧文：《寡居的一年》</p><p>格雷厄姆•乔伊斯：《牙齿仙子》</p><p>艾伦•贾德：《魔鬼的杰作》</p><p>罗杰•卡恩：《美梦成真》</p><p>玛丽•卡尔：《撒谎者俱乐部》</p><p>杰克•柯切姆：《生的权利》</p><p>塔碧莎•金：《幸存者》</p><p>塔碧莎•金：《水中天》（未出版）</p><p>芭芭拉•金索尔沃：《毒树圣经》</p><p>约翰•柯拉考尔：《挑战巅峰》</p><p>哈珀•李：《杀死一只知更鸟》</p><p>伯纳德•列夫科维奇：《我们的人》</p><p>本特利•利特尔：《被忽视的人》</p><p>诺尔曼•麦克利恩：《大河恋：作品集》</p><p>萨默塞特•毛姆：《月亮和六便士》</p><p>科马克•麦卡锡：《平原城市》</p><p>科马克•麦卡锡：《十字路口》</p><p>弗兰克•麦考特：《安吉拉的灰烬》</p><p>爱丽丝•麦克德莫特：《迷人比利》</p><p>杰克•麦克德维特：《远古海岸》</p><p>伊恩•麦克尤恩：《爱无可忍》</p><p>伊恩•麦克尤恩：《水泥花园》</p><p>拉里•麦克穆特里：《死人漫步》</p><p>拉里•麦克穆特里和戴安娜•奥萨纳：《契克和奈德》</p><p>沃特•米勒：《献给雷波维奇的圣歌》</p><p>乔伊丝•卡罗尔•欧茨：《行尸走肉》</p><p>蒂姆•奥布莱恩：《林中湖上》</p><p>斯图尔特•奥南：《超速女王》</p><p>迈克尔•翁达杰：《英国病人》</p><p>理查德•诺斯•帕特森：《无处安身》</p><p>理查德•普莱斯：《自由国度》</p><p>安妮•普劳克斯：《怀俄明故事集》</p><p>安妮•普劳克斯：《航运新闻》</p><p>安娜•昆德伦：《真理》</p><p>露丝•伦德尔：《见到你真好》</p><p>弗兰克•罗宾森：《等待》</p><p>J•K. 罗琳：《哈利•波特与密室》</p><p>J•K. 罗琳：《哈利•波特与阿兹卡班的囚徒》</p><p>J•K. 罗琳：《哈利•波特与魔法石》</p><p>理查德•鲁索：《莫霍克》</p><p>约翰•伯恩海姆•施瓦兹：《救赎之路》</p><p>维克兰•塞斯：《如意郎君》</p><p>欧文•肖：《幼狮》</p><p>理查德•斯罗特金：《弹坑》</p><p>蒂尼夏•史密斯：《魔术师》</p><p>斯科特•斯宾塞：《黑衣人》</p><p>华莱士•斯台戈纳：《乔•希尔》</p><p>多娜•塔特：《校园秘史》</p><p>安•泰勒：《补丁行星》</p><p>库尔特•冯内古特：《咒语》</p><p>伊夫林•沃：《故园风雨后》</p><p>唐纳德•韦斯特雷克：《斧》</p><h1 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;作者以桌子上的一块红布与笼子里背上写着蓝色8的兔子把我拉到了1997年他的身边，我仿佛穿越了。这是我第一次感受到文字的奥妙与神奇之处，写作已经深深吸引住了我。读到后面关于禁止使用被动语态，激动的我写下了有史以来第一段感觉还不错的这段文字。我走到了河边，看！河上有一艘船，大概有一辆公交车那么大，船头站着一个和尚，手执一个发着绿光的魔法棒。</p><p>写作最重要的就是要对自己所写的东西自信并热爱它，能够让自己和读者带入其中，把每个角色变成鲜活的生命，要真实真诚。</p>]]></content>
    
    
    <categories>
      
      <category>读书</category>
      
      <category>写作</category>
      
    </categories>
    
    
    <tags>
      
      <tag>斯蒂芬·金</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL数据库(一) —— 增删改查</title>
    <link href="/2020/10/04/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93(%E4%B8%80)/"/>
    <url>/2020/10/04/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93(%E4%B8%80)/</url>
    
    <content type="html"><![CDATA[<h1 id="数据库增删改查"><a href="#数据库增删改查" class="headerlink" title="数据库增删改查"></a><strong>数据库增删改查</strong></h1><h2 id="新建数据库"><a href="#新建数据库" class="headerlink" title="新建数据库"></a><strong>新建数据库</strong></h2><pre><code>create database if not exists 数据库名称 charset=字符集;</code></pre><h2 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a><strong>删除数据库</strong></h2><pre><code>drop database if exists 数据库名称;</code></pre><h2 id="修改数据库"><a href="#修改数据库" class="headerlink" title="修改数据库"></a><strong>修改数据库</strong></h2><pre><code>alter database 数据库名称 charset=字符集;</code></pre><h2 id="查看数据库"><a href="#查看数据库" class="headerlink" title="查看数据库"></a><strong>查看数据库</strong></h2><pre><code>show create database 数据库名称;show databases;</code></pre><h1 id="表增删改查"><a href="#表增删改查" class="headerlink" title="表增删改查"></a><strong>表增删改查</strong></h1><p><strong>注意点:<br>在对数据库的表进行操作的时候(增删改查), 都必须先告诉MySQL我们要操作的是哪一个数据库</strong></p><pre><code>use 数据库名称;</code></pre><h2 id="查看数据库中有哪些表"><a href="#查看数据库中有哪些表" class="headerlink" title="查看数据库中有哪些表"></a><strong>查看数据库中有哪些表</strong></h2><pre><code>show tables;</code></pre><h2 id="查看指定表的结构"><a href="#查看指定表的结构" class="headerlink" title="查看指定表的结构"></a><strong>查看指定表的结构</strong></h2><pre><code>desc 表名;</code></pre><h2 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a><strong>创建表</strong></h2><pre><code>create table if not exists 表名(  字段名称 数据类型,  字段名称 数据类型,);</code></pre><p><strong>注意点: 以上代码创建表, 没有就会创建一个新的, 有就会自动跳过</strong></p><h2 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a><strong>删除表</strong></h2><pre><code>drop table if exists 表名;</code></pre><p><strong>注意点: 以上语句, 如果需要删除的表存在, 那么就直接删除, 如果不存在就跳过</strong></p><h2 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a><strong>修改表</strong></h2><h3 id="修改表名"><a href="#修改表名" class="headerlink" title="修改表名"></a><strong>修改表名</strong></h3><pre><code>rename table 原始名称 to 新的名称;</code></pre><h3 id="添加字段"><a href="#添加字段" class="headerlink" title="添加字段"></a><strong>添加字段</strong></h3><pre><code>alter table 表名 add 新增字段名称 新增字段数据类型;</code></pre><p><strong>注意点:</strong> </p><p><strong>默认情况下会将新增的字段放到原有字段的后面</strong></p><pre><code>alter table 表名 add 字段名 数据类型 first;</code></pre><p><strong>我们可以通过指定first将新增的字段放到原有字段的前面</strong></p><pre><code>alter table 表名 add 字段名 数据类型 after 字段名;</code></pre><p><strong>我们可以通过after指定将新增的字段放到哪个字段的后面</strong></p><h3 id="删除字段"><a href="#删除字段" class="headerlink" title="删除字段"></a><strong>删除字段</strong></h3><pre><code>alter table 表名 drop 字段名称;</code></pre><h3 id="修改字段"><a href="#修改字段" class="headerlink" title="修改字段"></a><strong>修改字段</strong></h3><h4 id="修改字段的数据类型"><a href="#修改字段的数据类型" class="headerlink" title="修改字段的数据类型"></a><strong>修改字段的数据类型</strong></h4><pre><code>alter table 表名 modify 需要修改的字段名称 新的数据类型</code></pre><h4 id="修改字段的名称和数据类型"><a href="#修改字段的名称和数据类型" class="headerlink" title="修改字段的名称和数据类型"></a><strong>修改字段的名称和数据类型</strong></h4><pre><code>alter table 表名 change 原始字段名称 新的字段名称 新的数据类型;</code></pre><h1 id="数据增删改查"><a href="#数据增删改查" class="headerlink" title="数据增删改查"></a><strong>数据增删改查</strong></h1><h2 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a><strong>插入数据</strong></h2><pre><code>insert into 表名 (字段名称1, 字段名称2) values (值1, 值2);</code></pre><p><strong>注意点:</strong> </p><p><strong>在插入数据的时候指定的字段名称的顺序不用和表中的字段名称的顺序一致<br>在插入数据的时候指定的取值顺序必须和指定的字段名称顺序一致<br>如果插入数据时指定的取值顺序和表中的字段顺序是一致的, 那么可以不指定字段名称</strong></p><pre><code> insert into  stu values (值1, 值2), (值1, 值2);</code></pre><p><strong>注意点: 我们可以通过values同时插入多条数据</strong></p><h2 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a><strong>更新数据</strong></h2><pre><code>update 表名 set 字段名称=值 [where 条件];</code></pre><p><strong>注意点:</strong></p><p><strong>如果在更新数据的时候没有指定条件, 那么就会更新整张表中的数据<br>如果在更新数据的时候指定了条件, 那么只会更新满足条件的数据<br>在指定条件的时候, 我们可以通过AND来指定多个条件, AND<br>在指定条件的时候, 我们可以通过OR来指定多个条件, OR<br>在更新数据的时候是可以同时更新多个字段的,字段之间用逗号隔开</strong></p><h2 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a><strong>查询数据</strong></h2><p><strong>注意点:</strong> </p><p><strong>以下方式会将表中所有的数据都查询出来, 所以性能比较差, 不能查询特定字段的值</strong></p><pre><code>select * from 表名;</code></pre><p><strong>以下才是查询数据完整的写法</strong></p><pre><code>select 字段名称1, 字段名称2 from 表名 where 条件;</code></pre><p><strong>查询特定字段的数据</strong></p><pre><code>select 字段名称1 from 表名;</code></pre><p><strong>where支持的运算符</strong></p><ul><li>=、!=、&lt;&gt;、&lt;、&lt;=、&gt;、&gt;=；</li><li>IN(X,Y)；固定的范围值</li><li>BETWEEN X AND Y；值在什么范围</li><li>IS NULL；（为空） </li><li>IS NOT NULL；（不为空）</li><li>AND；与</li><li>OR；或</li><li>NOT；非</li><li>LIKE: 模糊查询</li></ul><h2 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a><strong>删除数据</strong></h2><pre><code>delete from 表名 where 条件;</code></pre><p><strong>删除所有的数据</strong></p><pre><code>delete from 表名;</code></pre><h1 id="MySQL存储引擎"><a href="#MySQL存储引擎" class="headerlink" title="MySQL存储引擎"></a><strong>MySQL存储引擎</strong></h1><ul><li><h2 id="MySQL中的三种存储引擎"><a href="#MySQL中的三种存储引擎" class="headerlink" title="MySQL中的三种存储引擎"></a><strong>MySQL中的三种存储引擎</strong></h2><ul><li>MyISAM: 安全性低, 但不支持事务和外键, 适合频繁插入和查询的应用</li><li>InnoDB(默认): 安全性高, 支持事务和外键, 适合对安全性, 数据完整性要求较高的应用</li><li>Memory: 访问速度极快, 但不会永久存储数据, 适合对读写速度要求较高的应用</li></ul></li></ul><p>创建时指定存储引擎</p><pre><code>create table if not exists 表名(          字段名称 数据类型,          字段名称 数据类型,        )engine=引擎名称;</code></pre><h3 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a><strong>InnoDB</strong></h3><p>如果表的存储引擎是InnoDB, 那么只要创建表就会自动创建一个文件, 这个文件就保存了这张表的结构, 如果往InnoDB的表中存储数据, 那么数据会被存储到ibdata1的文件中, 如果存储的数据比较多, 那么系统会自动再创建ibdata2, ibdata3, …文件</p><h3 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a><strong>MyISAM</strong></h3><p>如果表的存储引擎是MyISAM, 那么只要创建表就会自动创建三个文件</p><ul><li>.sdi这个文件就保存了这张表的结构</li><li>.MYD这个文件就保存了这张表中存储的数据</li><li>.MYI这个文件就保存了这张表中的索引</li></ul><h3 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a><strong>Memory</strong></h3><p>如果表的存储引擎是Memory, 那么只要创建表就会自动创建一个文件,这个文件就保存了这张表的结构<br><strong>注意点: 如果表的存储引擎是Memory, 那么就不会像InnoDB/MyISAM将数据保存到文件中了, 而是直接保存到内存中</strong></p><h2 id="修改存储引擎"><a href="#修改存储引擎" class="headerlink" title="修改存储引擎"></a><strong>修改存储引擎</strong></h2><pre><code>alter table 表名 engine=引擎名称;</code></pre>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
