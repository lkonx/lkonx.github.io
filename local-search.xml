<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>MySQL数据库(五) —— 事务</title>
    <link href="/2020/10/10/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93(%E4%BA%94)/"/>
    <url>/2020/10/10/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93(%E4%BA%94)/</url>
    
    <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p><strong>MySQL中的事务主要用于处理容易出错的数据。事务可以用来维护数据库的完整性，保证成批的 SQL 语句要么全部执行，要么全部不执行。用来管理 insert,update,delete语句。MySQL中只有使用了 Innodb 数据库引擎的表才支持事务。</strong></p><h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><p><strong>开启事务: start transaction<br>提交事务: commit<br>回滚事务: rollback</strong></p><pre><code>start transaction; // 开启事务SQL语句;rollback; // 任务失败, 回滚到开启之前状态SQL语句;commit; // 任务成功, 提交开启事务之后所有操作</code></pre><p><strong>注意点:<br>事务的本质是开启事务的时候拷贝一张一模一样的表，然后执行相关的操作都是在拷贝的这张表中做操作，如果失败了,如果执行了rollback,那么系统就会自动删除拷贝的这张表，所以失败了不会影响到原有的数据如果成功了,如果执行了commit,那么系统就会自动利用拷贝表中最新的数据覆盖原有表中的数据，所以成功了会影响到原有的数据</strong></p><h1 id="回滚点"><a href="#回滚点" class="headerlink" title="回滚点"></a>回滚点</h1><p><strong>savepoint 回滚点名称<br>rollback to 回滚点名称</strong></p><pre><code>start transaction;SQL语句;savepoint abc;SQL语句;savepoint def;SQL语句;rollback to abc;</code></pre><h1 id="事务特点"><a href="#事务特点" class="headerlink" title="事务特点"></a>事务特点</h1><h2 id="原子"><a href="#原子" class="headerlink" title="原子"></a>原子</h2><p><strong>事务开启后的所有操作，要么全部成功，要么全部失败，不可能出现部分成功的情况<br>事务执行过程中如果出错，哪怕我们不手动回滚, 系统也会自动帮我们回滚</strong></p><h2 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h2><p><strong>事务开始前和结束后，数据库的完整性约束没有被破坏<br>例如 A向B转账，不可能A扣了钱，B却没收到</strong></p><h2 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h2><p><strong>事务完成后，事务对数据库的所有操作是永久的, 操作完成之后就不能再回滚</strong></p><h2 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h2><p><strong>数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发时由于交叉执行而导致数据的不一致。</strong></p><h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><p><strong>读未提交（read uncommitted）: 一个事务可以读取另一个未提交事务的数据<br>读提交（read committed）: 一个事务要等另一个事务提交后才能读取数据<br>可重复读（repeatable read）: 一个事务范围内多个相同的查询返回相同的结果<br>串行化（serializable）: 前面一个事务没有执行完后面一个事务不能执行</strong></p><h4 id="查看隔离级别"><a href="#查看隔离级别" class="headerlink" title="查看隔离级别"></a>查看隔离级别</h4><pre><code>全局的: select @@global.transaction_isolation;当前会话的: select @@transaction_isolation;</code></pre><h4 id="设置隔离级别"><a href="#设置隔离级别" class="headerlink" title="设置隔离级别"></a>设置隔离级别</h4><pre><code>全局的: set global transaction isolation level 级别名称;当前会话: set session transaction isolation level 级别名称;</code></pre><h3 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h3><p><strong>读取到其它事务没有提交的数据</strong></p><p>A客户端:</p><pre><code>set session transaction isolation level read uncommitted;start transaction;update bank set money=money-1000 where cardId=&#39;1002&#39;;select * from bank;</code></pre><p>B客户端:</p><pre><code>set session transaction isolation level read uncommitted;select * from bank;</code></pre><p><strong>解决办法(read committed)</strong></p><p>A客户端:</p><pre><code>set session transaction isolation level read committed;start transaction;update bank set money=money-1000 where cardId=&#39;1002&#39;;select * from bank;</code></pre><p>B客户端:</p><pre><code>set session transaction isolation level read committed;select * from bank;</code></pre><h3 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h3><p><strong>一个事务范围内多次查询的结果不同</strong></p><p>A客户端:</p><pre><code>set session transaction isolation level read committed;start transaction;select * from bank;</code></pre><p>B客户端:</p><pre><code>set session transaction isolation level read committed;start transaction;update bank set money=money-1000 where cardId=&#39;1002&#39;;commit;</code></pre><p>A客户端:</p><pre><code>select * from bank;commit;</code></pre><p><strong>解决办法(repeatable read)</strong></p><h3 id="重复读"><a href="#重复读" class="headerlink" title="重复读"></a>重复读</h3><p><strong>一个事务范围内多次查询的结果相同</strong></p><p>A客户端:</p><pre><code>set session transaction isolation level repeatable read;start transaction;select * from bank;</code></pre><p>B客户端:</p><pre><code>set session transaction isolation level repeatable read;start transaction;update bank set money=money-1000 where cardid=&#39;1002&#39;;commit;</code></pre><p>A客户端:</p><pre><code>select * from bank;commit;</code></pre><p><strong>解决办法(serializable)</strong></p><h3 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h3><p><strong>读到到的结果并不是最终的结果</strong><br>A客户端:</p><pre><code>set session transaction isolation level serializable;start transaction;select * from bank;</code></pre><p>B客户端:</p><pre><code>set session transaction isolation level serializable;start transaction;update bank set money=money-1000 where cardid=&#39;1002&#39;;commit;</code></pre><p>A客户端:</p><pre><code>select * from bank;commit;</code></pre><h3 id="对应关系"><a href="#对应关系" class="headerlink" title="对应关系"></a>对应关系</h3><pre><code>事务隔离级别                    脏读   不可重复读    幻读读未提交（read-uncommitted）    是           是      是不可重复读（read-committed）    否           是      是可重复读（repeatable-read）     否           否      是串行化（serializable）          否           否      否</code></pre>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL数据库(四) —— 数据查询</title>
    <link href="/2020/10/09/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93(%E5%9B%9B)/"/>
    <url>/2020/10/09/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93(%E5%9B%9B)/</url>
    
    <content type="html"><![CDATA[<h1 id="单表查询"><a href="#单表查询" class="headerlink" title="单表查询"></a>单表查询</h1><pre><code>select * from 表名; #查询表中所有数据select 字段1, 字段2 from 表名; #查询表中指定字段数据select [* || 字段] from 表名 [where 条件]; #查询表中满足条件的数据</code></pre><h3 id="结果集"><a href="#结果集" class="headerlink" title="结果集"></a>结果集</h3><p><strong>通过查询语句查询出来的结果我们就称之为结果集，结果集以表的形式将查询的结果返回给我们</strong></p><p><strong>注意点:<br>结果集返回的表和查询的表不是同一张表，被查询的表是真实存在的, 是存储在磁盘上的，而结果集不是真实存在的, 是存储到内存中的</strong></p><h3 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h3><p><strong>查询指定字段数据时, 我们可以通过as给指定字段取别名</strong></p><pre><code>SELECT name as MyName, age as MyAge FROM stu;</code></pre><h4 id="字段表达式"><a href="#字段表达式" class="headerlink" title="字段表达式"></a>字段表达式</h4><p><strong>查询数据的时候, 除了可以查询指定字段的数据以外, 我们还可以查询表达式的结果</strong></p><pre><code>SELECT 6+6;</code></pre><h3 id="伪表"><a href="#伪表" class="headerlink" title="伪表"></a>伪表</h3><p><strong>字段表达式虽然能够查询出表达式的结果, 但是不符合MySQL的规范,所以我们可以通过伪表(dual)的方式让字段表达式符合MySQL的规范</strong></p><pre><code>SELECT 6+6 from dual;</code></pre><h2 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h2><p><strong>select 字段 from 表名 where 字段 like ‘条件’;</strong></p><p><strong>_通配符: 表示任意一个字符</strong></p><p><strong>%通配符: 表示任意0~n个字符</strong></p><pre><code>a_c: abc / adcabc,adc,abbc,ac_a_c: 1abc / 3adc1abc,abc1,2abbc,3adca%c:abc / adc / abbc / acabc,adc,abbc,ac%a%c: 1abc / 2abbc / 3adc1abc,abc1,2abbc,3adcselect * from stu where name like &#39;z_&#39;;select * from stu where name like &#39;z__&#39;;select * from stu where name like &#39;z_%&#39;;</code></pre><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><pre><code>select 字段 from 表名 order by 字段 [asc | desc];select * from stu order by age; #默认按照升序进行排序select * from stu order by age asc; # 升序排序select * from stu order by age desc; # 降序排序select * from stu order by age desc, score asc; </code></pre><p><strong>如果年龄相同, 那么还可以继续按照其它字段来排序</strong></p><h2 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h2><h3 id="count-统计"><a href="#count-统计" class="headerlink" title="count() 统计"></a>count() 统计</h3><pre><code>select count(*) from stu;select count(*) from stu where score &gt;= 60;</code></pre><h3 id="sum-求和"><a href="#sum-求和" class="headerlink" title="sum() 求和"></a>sum() 求和</h3><pre><code>select sum(id) from stu;</code></pre><h3 id="avg-求平均值"><a href="#avg-求平均值" class="headerlink" title="avg() 求平均值"></a>avg() 求平均值</h3><pre><code>select avg(id) from stu; # 21 / 6 = 3.5select avg(score) from stu;</code></pre><h3 id="max-获取最大值"><a href="#max-获取最大值" class="headerlink" title="max() 获取最大值"></a>max() 获取最大值</h3><pre><code>select max(score) from stu;</code></pre><h3 id="min-获取最小值"><a href="#min-获取最小值" class="headerlink" title="min() 获取最小值"></a>min() 获取最小值</h3><pre><code>select min(score) from stu;</code></pre><h3 id="rand-生成随机数"><a href="#rand-生成随机数" class="headerlink" title="rand() 生成随机数"></a>rand() 生成随机数</h3><pre><code>select rand() from dual;select * from stu order by rand();</code></pre><h3 id="round-四舍五入"><a href="#round-四舍五入" class="headerlink" title="round() 四舍五入"></a>round() 四舍五入</h3><pre><code>select round(3.1) from dual;select round(3.5) from dual;</code></pre><h3 id="ceil-向上取整"><a href="#ceil-向上取整" class="headerlink" title="ceil() 向上取整"></a>ceil() 向上取整</h3><pre><code>select ceil(3.1) from dual;</code></pre><h3 id="floor-向下取整"><a href="#floor-向下取整" class="headerlink" title="floor() 向下取整"></a>floor() 向下取整</h3><pre><code>select floor(3.9) from dual;</code></pre><h3 id="truncate-截取小数位"><a href="#truncate-截取小数位" class="headerlink" title="truncate() 截取小数位"></a>truncate() 截取小数位</h3><pre><code>select truncate(3.1234567, 2) from dual;</code></pre><p>ucase() 转换为大写</p><pre><code>select ucase(&#39;hello world&#39;) from dual;</code></pre><p>lcase() 转换为小写</p><pre><code>select lcase(&#39;HELLO WORLD&#39;) from dual;</code></pre><p>left() 从左边开始截取到指定的位置</p><pre><code>select left(&#39;1234567890&#39;, 3) from dual;</code></pre><p>right() 从右边开始截取到指定的位置</p><pre><code>select right(&#39;1234567890&#39;, 3) from dual;</code></pre><p>substring() 从指定位置开始截取指定个字符</p><pre><code>select substring(&#39;1234567890&#39;, 3, 5) from dual;</code></pre><h2 id="数据分组"><a href="#数据分组" class="headerlink" title="数据分组"></a>数据分组</h2><pre><code>select 分组字段 || 聚合函数 from 表名 group by 分组字段;需求: 要求统计表中一共有多少个城市select city from stu;select city from stu group by city;</code></pre><p><strong>需求: 要求统计每个城市中有多少个人</strong></p><pre><code>select city, count(*) from stu group by city;</code></pre><p><strong>注意点:<br>在对数据进行分组的时候, select 后面必须是分组字段或者聚合函数, 否则就只会返回第一条数据</strong></p><pre><code>select city from stu group by city;select name from stu group by city;select city, group_concat(name) from stu group by city;</code></pre><h2 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h2><p><strong>having和where很像都是用来做条件查询的<br>但是where是去数据库中查询符合条件的数据<br>而having是去结果集中查询符合条件的数据</strong></p><pre><code>select name, age from stu where city=&#39;北京&#39;;  //不会报错select name, age from stu having city=&#39;北京&#39;; //报错#Unknown column &#39;city&#39; in &#39;having clause&#39;</code></pre><h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><pre><code>select 字段 from 表 limit 索引, 个数;select * from stu limit 0, 3;select * from stu limit 3, 3;</code></pre><h2 id="查询选项"><a href="#查询选项" class="headerlink" title="查询选项"></a>查询选项</h2><p><strong>select [查询选项] 字段名称 from 表名;</strong></p><p><strong>all:      显示所有查询出来的数据[默认]<br>distinct: 去除结果集中重复的数据之后再显示</strong></p><pre><code>select name from stu;select all name from stu;select distinct name from stu;</code></pre><p><strong>注意点:</strong><br><strong>如果是通过distinct来对结果集中重复的数据进行去重，那么只有所有列的数据都相同才会去重</strong></p><pre><code>select name, score from stu;select distinct name, score from stu;</code></pre><h2 id="完整的查询语句"><a href="#完整的查询语句" class="headerlink" title="完整的查询语句"></a>完整的查询语句</h2><pre><code>select [查询选项] 字段名称 [from 表名] [where 条件] [order by 排序] [group by 分组] [having 条件] [limit 分页];</code></pre><h1 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h1><p><strong>多表查询只需要在单表查询基础上增加一张表即可</strong></p><p>*<em>select * from 表名1, 表名2;*</em></p><pre><code>select * from stu, grade;</code></pre><p><strong>注意点:<br>默认情况下多表查询的结果是笛卡尔集</strong></p><h2 id="union"><a href="#union" class="headerlink" title="union"></a>union</h2><p><strong>在纵向上将多张表的结果结合起来返回给我们</strong><br><strong>select * from 表名1 union select * from 表名2</strong></p><pre><code>select id, name from stu union select id, score from grade;</code></pre><p><strong>注意点:</strong><br><strong>使用union进行多表查询, 返回的结果集的表头的名称是第一张表的名称<br>使用union进行多表查询, 必须保证多张表查询的字段个数一致</strong></p><pre><code>select id, name from stu union select id, score, stuId from grade;#The used SELECT statements have a different number of columns</code></pre><p><strong>使用union进行多表查询, 默认情况下会自动去重</strong></p><pre><code>  select id, name from stu union select id, name from person;</code></pre><p><strong>使用union进行多表查询, 如果不想自动去重, 那么可以在union后面加上all</strong></p><pre><code>  select id, name from stu union all select id, name from person;</code></pre><h2 id="表的连接查询"><a href="#表的连接查询" class="headerlink" title="表的连接查询"></a>表的连接查询</h2><p><strong>将多张表中’关联的字段’’连接’在一起查询我们称之为’表的连接查询’<br>大白话: 查询多张表中满足条件的数据</strong></p><h3 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h3><pre><code>select * from stu, grade where stu.id = grade.stuId;select * from 表名1 inner join 表名2 on 条件;select * from stu inner join grade on stu.id = grade.stuId;</code></pre><p><strong>注意点:<br>在进行多表查询的时候, 如果想查询指定的字段, 那么必须在字段名称前面加上表名才行</strong></p><pre><code>  select stu.id, stu.name, grade.score from stu inner join grade on stu.id = grade.stuId;</code></pre><p><strong>在内连接中只会返回满足条件的数据</strong></p><h3 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h3><h4 id="左外连接"><a href="#左外连接" class="headerlink" title="左外连接"></a>左外连接</h4><p><strong>在左外连接中, 左边的表是不看条件的, 无论条件是否满足, 都会返回左边表中所有的数据<br>在左外连接中, 只有右边的表会看条件, 对于右边的表而言, 只有满足条件才会返回对应的数据</strong></p><pre><code>select stu.id, stu.name, grade.score from stu left join grade on stu.id = grade.stuId;</code></pre><p><strong>在以上的查询语句中stu表在左边, grade表在右边<br>所以stu表不看条件, 只有grade表看条件</strong></p><h4 id="右外连接"><a href="#右外连接" class="headerlink" title="右外连接"></a>右外连接</h4><p><strong>在右外连接中, 右边的表是不看条件的, 无论条件是否满足, 都会返回右边表中所有的数据<br>在右外连接中, 只有左边的表会看条件, 对于左边的表而言, 只有满足条件才会返回对应的数据</strong></p><pre><code>select stu.id, stu.name, grade.score from stu right join grade on stu.id = grade.stuId;</code></pre><p><strong>在以上的查询语句中stu表在左边, grade表在右边<br>所以grade表不看条件, 只有stu表看条件</strong></p><h3 id="交叉连接"><a href="#交叉连接" class="headerlink" title="交叉连接"></a>交叉连接</h3><p><strong>如果没有指定条件, 那么返回笛卡尔集</strong></p><pre><code>select stu.id, stu.name, grade.score from stu cross join grade;</code></pre><p><strong>如果指定了条件, 那么就等价于内连接</strong></p><pre><code>select stu.id, stu.name, grade.score from stu cross join grade on stu.id = grade.stuId;</code></pre><h3 id="全连接-MySQL不支持全连接"><a href="#全连接-MySQL不支持全连接" class="headerlink" title="全连接(MySQL不支持全连接)"></a>全连接(MySQL不支持全连接)</h3><h3 id="自然连接-natural"><a href="#自然连接-natural" class="headerlink" title="自然连接(natural)"></a>自然连接(natural)</h3><p><strong>自然连接是用来简化’内连接和外连接’的，如果多张表需要判断的条件字段名称一致, 那么不用编写条件, 自然连接会自动判断</strong></p><h4 id="自然内连接"><a href="#自然内连接" class="headerlink" title="自然内连接"></a>自然内连接</h4><pre><code>select * from 表名1 inner join 表名2 on 条件;select * from stu inner join grade on stu.id = grade.stuId;select * from 表名1 natural join 表名2;select * from stu natural join grade;</code></pre><h4 id="自然外连接"><a href="#自然外连接" class="headerlink" title="自然外连接"></a>自然外连接</h4><h5 id="自然左外连接"><a href="#自然左外连接" class="headerlink" title="自然左外连接"></a>自然左外连接</h5><pre><code>select * from stu natural left join grade;</code></pre><h5 id="自然右外连接"><a href="#自然右外连接" class="headerlink" title="自然右外连接"></a>自然右外连接</h5><pre><code>select * from stu natural right join grade;</code></pre><p><strong>注意点:<br>如果没有指定条件, 也没有同名的字段, 那么就会返回笛卡尔集<br>在自然连接中, 返回的结果集会自动优化, 会自动去除重复的判断字段</strong></p><h3 id="using关键字"><a href="#using关键字" class="headerlink" title="using关键字"></a>using关键字</h3><p><strong>如果多张表需要判断的条件字段名称一致, 那么除了可以使用自然连接来简化以外<br>还可以使用using关键字来简化</strong></p><h4 id="内连接-1"><a href="#内连接-1" class="headerlink" title="内连接"></a>内连接</h4><pre><code>select * from stu inner join grade on stu.stuId = grade.stuId;select * from stu inner join grade using(stuId);</code></pre><h4 id="外连接-1"><a href="#外连接-1" class="headerlink" title="外连接"></a>外连接</h4><h5 id="左外连接-1"><a href="#左外连接-1" class="headerlink" title="左外连接"></a>左外连接</h5><pre><code>select * from stu left join grade on stu.stuId = grade.stuId;select * from stu left join grade using(stuId);</code></pre><h5 id="右外连接-1"><a href="#右外连接-1" class="headerlink" title="右外连接"></a>右外连接</h5><pre><code>select * from stu right join grade on stu.stuId = grade.stuId;select * from stu right join grade using(stuId);</code></pre><h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><p><strong>将一个查询语句查询的结果作为另一个查询语句的条件来使用</strong><br><strong>将一个查询语句查询的结果作为另一个查询语句的表来使用</strong></p><h4 id="标准子查询"><a href="#标准子查询" class="headerlink" title="标准子查询"></a>标准子查询</h4><p><strong>返回的结果只有一个</strong></p><pre><code>select stuId from grade where score = 100;select name from stu where stuId = 3;select name from stu where stuId = (select stuId from grade where score = 100);</code></pre><h4 id="非标准子查询"><a href="#非标准子查询" class="headerlink" title="非标准子查询"></a>非标准子查询</h4><p><strong>返回的结果有多个</strong></p><pre><code>select stuId from grade where score &gt;= 60;select name from stu where stuId = 3 OR stuId = 1;select name from stu where stuId in(3, 1);select name from stu where stuId in(select stuId from grade where score &gt;= 60);</code></pre><p><strong>将一个查询语句查询的结果作为另一个查询的表来使用</strong></p><pre><code>select name, city, score from person where score &gt;= 60;select name, city, score from (select name, city, score from person where score &gt;= 60) as t;</code></pre><p><strong>注意点:<br>如果要将一个查询语句查询的结果作为另一个查询的表来使用, 那么必须给子查询起一个别名</strong></p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL数据库(三) —— 数据的完整性</title>
    <link href="/2020/10/08/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93(%E4%B8%89)/"/>
    <url>/2020/10/08/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93(%E4%B8%89)/</url>
    
    <content type="html"><![CDATA[<h1 id="数据完整性"><a href="#数据完整性" class="headerlink" title="数据完整性"></a>数据完整性</h1><p><strong>数据的完整性保存到数据库中的数据都是正确的，数据的完整性可以分为三类: 实体完整性、域完整性、参照完整性，无论是哪一种完整性都是在创建表时给表添加约束即可。</strong></p><h1 id="实体完整性"><a href="#实体完整性" class="headerlink" title="实体完整性"></a>实体完整性</h1><p><strong>表中的一行数据就是一个实体（entity）保证实体完整性就是保证每一行数据的唯一性，约束类型：主键约束（primary key），唯一约束(unique)，自动增长列(auto_increment)</strong></p><h2 id="主键约束"><a href="#主键约束" class="headerlink" title="主键约束"></a>主键约束</h2><p><strong>主键用于唯一标识表中的每一条数据, 和现实生活中的身份证很像</strong></p><pre><code>create table person2(    id int primary key,    name varchar(20));insert into person2 values (1, &#39;lkonx&#39;);insert into person2 values (2, &#39;lkonx&#39;);</code></pre><p><strong>主键的特征:</strong><br><strong>如果将某一个字段设置成了主键, 那么这个字段的取值就不能重复了<br>如果将某一个字段设置成了主键, 那么这个字段的取值就不能是null了<br>一张表中只能有一个主键, 不能出现多个主键</strong></p><pre><code>create table person3(    id int primary key,    name varchar(20) primary key);</code></pre><p><strong>我们除了可以在字段数据类型后面添加primary key,将这个字段变成主键以外,还可以通过在最后写上primary key(字段名称)的方式来指定主键</strong></p><pre><code>create table person3(    id int,    name varchar(20),    primary key(id));insert into person3 values (1, &#39;lkonx&#39;);insert into person3 values (1, &#39;lkonx&#39;);</code></pre><h3 id="联合主键"><a href="#联合主键" class="headerlink" title="联合主键"></a>联合主键</h3><p>我们通过将表中的某个永远不重复的字段设置为主键, 从而达到保证每一行数据的唯一性(实体完整性)，但是在企业开发中有时候我们可能找不到不重复的字段, 此时我们还可以通过联合主键的方式来保证每一行数据的唯一性，联合主键就是同时将多个字段作为一个主键来使用</p><pre><code> ___________|name  | age||lkonx | 88 ||zs    | 88 ||lkonx | 33 |create table person(    name varchar(20),    age int,    primary key(name, age));insert into person values (&#39;lkonx&#39;, 88);insert into person values (&#39;lkonx&#39;, 88);</code></pre><p><strong>注意点:<br>联合主键并不是添加多个主键, 而是将多个字段的值作为主键来使用<br>也就是过去我们指定id为主键, 那么id的取值不能重复<br>而现在如果我们指定 name和age为主键, 那么name+age的值不能重复</strong></p><h2 id="唯一约束"><a href="#唯一约束" class="headerlink" title="唯一约束"></a>唯一约束</h2><p><strong>唯一约束用于保证某个字段的值永远不重复</strong></p><pre><code>create table person(    id int unique,    name varchar(20));insert into person values (1, &#39;lkonx&#39;);insert into person values (1, &#39;lkonx&#39;);</code></pre><p><strong>主键和唯一键异同:<br>唯一约束和主键约束一样, 被约束的字段的取值都不能够重复<br>主键在一张表中只能有一个, 而唯一约束在一张表中可以有多个</strong></p><pre><code>create table person2(    id int unique,    name varchar(20) unique);insert into person2 values (1, &#39;lkonx&#39;);insert into person2 values (2, &#39;lkonx&#39;);</code></pre><p><strong>主键的取值不能为Null, 而唯一约束的取值可以是Null</strong></p><h2 id="自动增长约束"><a href="#自动增长约束" class="headerlink" title="自动增长约束"></a>自动增长约束</h2><p><strong>自动增长约束的作用是让某个字段的取值从1开始递增, 从而保证实体完整性</strong></p><pre><code>create table person(    id int auto_increment,    name varchar(20));#Incorrect table definition; there can be only one auto column and it must be defined as a key</code></pre><p><strong>注意点:<br>如果某个字段是自动增长的, 那么这个字段必须是主键才可以</strong></p><pre><code>create table person(    id int auto_increment primary key,    name varchar(20));insert into person values (1, &#39;lkonx&#39;);</code></pre><p><strong>如果仅仅是主键, 那么取值不能是null, 但是如果主键还是自动增长的, 那么取值就可以是null或者default</strong></p><p><strong>在企业开发中选择主键<br>最少性: 能用一个字段作为主键, 就不要使用多个字段<br>稳定性: 能用不被操作(修改)的字段作为主键, 就不要使用会被操作的字段作为主键<br>一般情况下我们会定义一个名称叫做id的字段, 并且这个字段是整型的, 并且这个字段是自动增长的来作为主键</strong></p><h2 id="如何修改约束"><a href="#如何修改约束" class="headerlink" title="如何修改约束"></a>如何修改约束</h2><p><strong>修改主键约束</strong></p><p><strong>alter table 表名 add primary key(字段);</strong></p><pre><code>create table person(    id int,    name varchar(20));alter table person add primary key(id);insert into person values (1, &#39;lkonx&#39;);</code></pre><p>修改唯一约束</p><p><strong>alter table 表名 add unique(字段);</strong></p><pre><code>create table person2(    id int,    name varchar(20));alter table person2 add unique(name);insert into person2 values (1, &#39;lkonx&#39;);</code></pre><p><strong>修改自动增长约束</strong></p><p><strong>alter table 表名 modify 字段名称 数据类型 auto_increment;</strong></p><pre><code>create table person3(    id int,    name varchar(20));alter table person3 modify id int auto_increment;insert into person3 values (null, &#39;lkonx&#39;);</code></pre><h1 id="域完整性"><a href="#域完整性" class="headerlink" title="域完整性"></a>域完整性</h1><p><strong>一行数据中的每个单元格都是一个域, 保证域的完整性就是保证每个单元格数据的正确性</strong></p><p><strong>例如: 人的年龄不可能超过255岁, 而且不能是负数, 所以我们就可以使用 TINYINT UNSIGNED</strong></p><p><strong>例如: 人的性别只能是男/女或者妖, 所以就可以使用枚举类型</strong></p><p><strong>例如: 要存储比较多的文字, 为了保证不超出每一行最大的存储限制,我们就可以使用大文本类型</strong></p><p><strong>使用非空约束（not null）使用默认值约束(default)</strong></p><pre><code>create table person(    id int,    name varchar(20) not null);insert into person values (1, null);create table person2(    id int,    name varchar(20) default &#39;it666&#39;);insert into person2 values (1, null);insert into person2 values (1, default);insert into person2 values (1, &#39;zs&#39;);</code></pre><p><strong>注意点: 哪怕设置了默认值, 传入null之后也不会使用默认值</strong></p><h1 id="参照完整性"><a href="#参照完整性" class="headerlink" title="参照完整性"></a>参照完整性</h1><p><strong>参照完整性又称引用完整性, 主要用于保证多表之间引用关系的正确性</strong></p><h2 id="使用多表"><a href="#使用多表" class="headerlink" title="使用多表"></a>使用多表</h2><p><strong>定义一张表保存2个学生3门课程的成绩</strong></p><pre><code>|---------------------------------|| id | name | gender | km | score || 1  | 张三 |   男   |语文|  100  || 2  | 张三 |   男   |数学|   99  || 3  | 张三 |   男   |英语|   98  || 4  | 李四 |   女   |语文|   60  || 5  | 李四 |   女   |数学|   59  || 6  | 李四 |   女   |英语|   58  ||---------------------------------|</code></pre><p><strong>如果将所有的数据都放到一张表中, 会出现大量冗余数据<br>所以为了降低数据库的体积, 提升数据库的效率, 我们需要根据自身需求对表进行拆分</strong></p><pre><code>|--------------------|      |-----------------------|| id | name | gender |      | id | km | score | uid || 1  | 张三 |   男   |      |  1 |语文|  100  |  1  || 2  | 李四 |   女   |      |  2 |数学|   99  |  1  ||--------------------|      |  3 |英语|   98  |  1  |                            |  4 |语文|   60  |  2  |                            |  5 |数学|   59  |  2  |                            |  6 |英语|   58  |  2  |                            |-----------------------|</code></pre><h2 id="冗余数据"><a href="#冗余数据" class="headerlink" title="冗余数据"></a>冗余数据</h2><p><strong>表与表之间的关系可以分为三种: 一对一、一对多、多对多</strong></p><h3 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h3><p><strong>一夫一妻制</strong></p><pre><code>|-----------------------------|| id | name | gender | mateId || 1  | 张三 |   男   |    2   || 2  | 李四 |   女   |    1   || 3  | 王五 |   男   |    4   || 4  | 赵六 |   女   |    2   ||-----------------------------|</code></pre><h3 id="一对多"><a href="#一对多" class="headerlink" title="一对多"></a>一对多</h3><p><strong>一个人有多个汽车，一个班有多个学生，一个人有多们成绩</strong></p><pre><code>|---------------------------------|| id | name | gender | km | score || 1  | 张三 |   男   |语文|  100  || 2  | 张三 |   男   |数学|   99  || 3  | 张三 |   男   |英语|   98  || 4  | 李四 |   女   |语文|   60  || 5  | 李四 |   女   |数学|   59  || 6  | 李四 |   女   |英语|   58  ||---------------------------------||--------------------|      |-----------------------|| id | name | gender |      | id | km | score | uid || 1  | 张三 |   男   |      |  1 |语文|  100  |  1  || 4  | 李四 |   女   |      |  2 |数学|   99  |  1  ||--------------------|      |  3 |英语|   98  |  1  |                            |  4 |语文|   60  |  2  |                            |  5 |数学|   59  |  2  |                            |  6 |英语|   58  |  2  |                            |-----------------------|</code></pre><h3 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h3><p><strong>一个学生有多个老师, 一个老师有多个学生</strong></p><pre><code>|--------------------------------------------|| id | stuName | gender | teacherName | 性别 || 1  |   张三  |   男   |     王五    |  男  || 2  |   张三  |   男   |     赵六    |  女  || 3  |   张三  |   男   |     周七    |  男  || 4  |   李四  |   女   |     王五    |  男  || 5  |   李四  |   女   |     赵六    |  女  || 6  |   李四  |   女   |     周七    |  男  ||--------------------------------------------||-----------------------|  |---------------------|   |-----------------------|| id | stuName | gender |  | stuId  | teacherId  |   | id | stuName | gender || 1  |   张三  |   男   |  |    1   |     1      |   | 1  |   王五  |   男   || 2  |   李四  |   女   |  |    1   |     2      |   | 2  |   赵六  |   女   ||-----------------------|  |    1   |     3      |   | 3  |   周七  |   男   |                           |    2   |     1      |   |-----------------------|                           |    2   |     2      |                           |    2   |     3      |                           |---------------------|</code></pre><h2 id="保证参照完整性"><a href="#保证参照完整性" class="headerlink" title="保证参照完整性"></a>保证参照完整性</h2><p><strong>默认情况下表与表之间是独立存在的, 不会相互影响，也正是因为如此, 默认情况下也不会检查表与表之间的依赖关系，所以为了保证表与表之间参照完整性, 我们可以通过’外键’来保证参照完整性</strong></p><pre><code>create table stu(    id int auto_increment primary key,    name varchar(20),    gender enum(&#39;男&#39;,&#39;女&#39;,&#39;妖&#39;));create table grade(    id int auto_increment primary key,    km varchar(20),    score double,    uid int);</code></pre><h3 id="外键"><a href="#外键" class="headerlink" title="外键"></a>外键</h3><p><strong>什么是外键?</strong><br><strong>如果一张表中有一个字段指向了别一张表中的主键，就将该字段叫做外键<br>例如: 成绩表中的uid引用了学生表中的id, 那么成绩表中的uid我们就称之为外键</strong></p><pre><code>|--------------------|      |-----------------------|| id | name | gender |      | id | km | score | uid || 1  | 张三 |   男   |      |  1 |语文|  100  |  1  || 2  | 李四 |   女   |      |  2 |数学|   99  |  1  ||--------------------|      |  3 |英语|   98  |  1  |                            |  4 |语文|   60  |  2  |                            |  5 |数学|   59  |  2  |                            |  6 |英语|   58  |  2  |                            |-----------------------|create table grade2(    id int auto_increment primary key,    km varchar(20),    score double,    uid int,    foreign key(uid) references stu(id));</code></pre><p><strong>注意点:</strong><br><strong>只有InnoDB的存储引擎才支持外键约束</strong></p><p><strong>外键的数据类型必须和指向的主键一样</strong></p><p><strong>在一对多的关系中, 外键一般定义在多的一方(一个学生有多门成绩, 那么外键定义在成绩表中)</strong></p><p><strong>定义外键的表我们称之为从表, 被外键引用的表我们称之为主表</strong></p><h4 id="创建表时定义外键"><a href="#创建表时定义外键" class="headerlink" title="创建表时定义外键"></a>创建表时定义外键</h4><pre><code>foreign key(外键字段名称) references 主表名称(主表主键名称);</code></pre><h3 id="动态添加外键"><a href="#动态添加外键" class="headerlink" title="动态添加外键"></a>动态添加外键</h3><p><strong>alter table 从表名称 add foreign key(外键字段名称) references</strong> 主表名称(主表主键名称);</p><pre><code>create table grade(    id int auto_increment primary key,    km varchar(20),    score double,    uid int);alter table grade add foreign key(uid) references stu(id);</code></pre><h3 id="查看外键"><a href="#查看外键" class="headerlink" title="查看外键"></a>查看外键</h3><p>show create table 从表名称;</p><pre><code>show create table grade;CREATE TABLE `grade` (  `id` int NOT NULL AUTO_INCREMENT,  `km` varchar(20) DEFAULT NULL,  `score` double DEFAULT NULL,  `uid` int DEFAULT NULL,  PRIMARY KEY (`id`),  KEY `uid` (`uid`),  CONSTRAINT `grade_ibfk_1` FOREIGN KEY (`uid`) REFERENCES `stu` (`id`)) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8</code></pre><p><strong>注意点:</strong></p><p><strong>CONSTRAINT <code>grade_ibfk_1</code> FOREIGN KEY (<code>uid</code>) REFERENCES <code>stu</code> (<code>id</code>)含义是将uid变成外键, 外键的名称是grade_ibfk_1</strong></p><p><strong>uid的取值引用的是stu这张表中的id字段的值</strong></p><h3 id="动态删除外键"><a href="#动态删除外键" class="headerlink" title="动态删除外键"></a>动态删除外键</h3><p>alter table 从表名称 drop foreign key 外键名称;</p><pre><code>alter table grade drop foreign key grade_ibfk_1;</code></pre><h3 id="外键的操作"><a href="#外键的操作" class="headerlink" title="外键的操作"></a>外键的操作</h3><h4 id="严格操作"><a href="#严格操作" class="headerlink" title="严格操作"></a>严格操作</h4><p><strong>主表不存在对应数据,从表不允许添加</strong><br><strong>从表引用着数据,主表不允许删除</strong><br><strong>从表引用这数据, 主表不允许修改</strong></p><h4 id="置空操作-null"><a href="#置空操作-null" class="headerlink" title="置空操作(null)"></a>置空操作(null)</h4><p><strong>在企业开发中, 我们可能必须要删除主表中的数据,但是如果主表被删除了从表就不完整了，所以在企业开发中, 我们可以通过置空操作, 在删除主表数据的同时删除从表关联的数据</strong></p><pre><code>create table grade2(    id int auto_increment primary key,    km varchar(20),    score double,    uid int,    foreign key(uid) references stu(id) on delete set null);</code></pre><h4 id="级联操作-cascade"><a href="#级联操作-cascade" class="headerlink" title="级联操作(cascade)"></a>级联操作(cascade)</h4><p>在企业开发中, 我们可能必须要修改主表中的数据,但是如果主表被修改了从表就不完整了，所以在企业开发中, 我们可以通过’级联操作’, 在修改主表数据的同时修改从表关联的数据</p><pre><code>create table grade3(    id int auto_increment primary key,    km varchar(20),    score double,    uid int,    foreign key(uid) references stu(id) on update cascade);</code></pre><p><strong>[constraint 外键名称] foreign key(外键字段) references 主表(主键) [主表删除的动作] [主表更新的动作]</strong><br><strong>一般情况下主表删除时从表置空, 主表更新时从表级联</strong></p><h3 id="多对多外键"><a href="#多对多外键" class="headerlink" title="多对多外键"></a>多对多外键</h3><pre><code>        学生表                     关系表                     教师表|-----------------------|  |---------------------|   |-----------------------|| id | stuName | gender |  | stuId  | teacherId  |   | id | stuName | gender || 1  |   张三  |   男   |  |    1   |     1      |   | 1  |   王五  |   男   || 2  |   李四  |   女   |  |    1   |     2      |   | 2  |   赵六  |   女   ||-----------------------|  |    1   |     3      |   | 3  |   周七  |   男   |                           |    2   |     1      |   |-----------------------|                           |    2   |     2      |                           |    2   |     3      |                           |---------------------|create table stu(    id int auto_increment primary key,    name varchar(20),    gender enum(&#39;男&#39;,&#39;女&#39;,&#39;妖&#39;));insert into stu values (null, &#39;张三&#39;, &#39;男&#39;);insert into stu values (null, &#39;李四&#39;, &#39;女&#39;);create table teacher(    id int auto_increment primary key,    name varchar(20),    gender enum(&#39;男&#39;,&#39;女&#39;,&#39;妖&#39;));insert into teacher values (null, &#39;王五&#39;, &#39;男&#39;);insert into teacher values (null, &#39;赵六&#39;, &#39;女&#39;);insert into teacher values (null, &#39;周七&#39;, &#39;男&#39;);create table rel(    stuId int,    teacherId int);insert into rel values (1, 1);insert into rel values (1, 2);insert into rel values (1, 3);insert into rel values (2, 1);insert into rel values (2, 2);insert into rel values (2, 3);alter table rel add foreign key(stuId) references stu(id);alter table rel add foreign key(teacherId) references teacher(id);insert into rel values (3, 1);#报错insert into rel values (1, 4);#报错</code></pre>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL数据库(二) —— 数据类型</title>
    <link href="/2020/10/07/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93(%E4%BA%8C)/"/>
    <url>/2020/10/07/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93(%E4%BA%8C)/</url>
    
    <content type="html"><![CDATA[<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="整型类型"><a href="#整型类型" class="headerlink" title="整型类型"></a>整型类型</h2><p><strong>专门用来保存整数的</strong></p><pre><code class="hljs angelscript">TINYINT         <span class="hljs-number">1</span> 字节  (<span class="hljs-number">-128</span>，<span class="hljs-number">127</span>)(<span class="hljs-number">0</span>，<span class="hljs-number">255</span>)小整数值SMALLINT        <span class="hljs-number">2</span> 字节  (<span class="hljs-number">-32</span> <span class="hljs-number">768</span>，<span class="hljs-number">32</span> <span class="hljs-number">767</span>)(<span class="hljs-number">0</span>，<span class="hljs-number">65</span> <span class="hljs-number">535</span>)大整数值MEDIUMINT       <span class="hljs-number">3</span> 字节  (<span class="hljs-number">-8</span> <span class="hljs-number">388</span> <span class="hljs-number">608</span>，<span class="hljs-number">8</span> <span class="hljs-number">388</span> <span class="hljs-number">607</span>)(<span class="hljs-number">0</span>，<span class="hljs-number">16</span> <span class="hljs-number">777</span> <span class="hljs-number">215</span>)大整数值INT或INTEGER    <span class="hljs-number">4</span> 字节  (<span class="hljs-number">-2</span> <span class="hljs-number">147</span> <span class="hljs-number">483</span> <span class="hljs-number">648</span>，<span class="hljs-number">2</span> <span class="hljs-number">147</span> <span class="hljs-number">483</span> <span class="hljs-number">647</span>)(<span class="hljs-number">0</span>，<span class="hljs-number">4</span> <span class="hljs-number">294</span> <span class="hljs-number">967</span> <span class="hljs-number">295</span>)大整数值BIGINT          <span class="hljs-number">8</span> 字节  (<span class="hljs-number">-9</span>,<span class="hljs-number">223</span>,<span class="hljs-number">372</span>,<span class="hljs-number">036</span>,<span class="hljs-number">854</span>,<span class="hljs-number">775</span>,<span class="hljs-number">808</span>，<span class="hljs-number">9</span> <span class="hljs-number">223</span> <span class="hljs-number">372</span> <span class="hljs-number">036</span> <span class="hljs-number">854</span> <span class="hljs-number">775</span> <span class="hljs-number">807</span>)(<span class="hljs-number">0</span>，<span class="hljs-number">18</span> <span class="hljs-number">446</span> <span class="hljs-number">744</span> <span class="hljs-number">073</span> <span class="hljs-number">709</span> <span class="hljs-number">551</span> <span class="hljs-number">615</span>)极大整数值</code></pre><p><strong>注意点:</strong></p><p>MySQL中的整型区分有符号和无符号，默认情况下整型就是有符号的，我们可以在数据类型的后面加上unsigned来将数据类型变成无符号的</p><pre><code>create table person2(    id int,    age tinyint unsigned);insert into person values (1, -128); #报错insert into person values (1, 127);insert into person values (1, 128);</code></pre><p>在保存数据的时候, 如果超出了当前数据类型的范围, 那么就会报错</p><pre><code>create table person(    id int,    age tinyint);insert into person values (1, -128);insert into person values (1, 127);insert into person values (1, 128); #报错</code></pre><p>在设置整型的时候, 还可以设置整型数据将来显示的位宽</p><pre><code>create table person3(    id int,    age tinyint(2) zerofill);insert into person values (1, 1);   #01insert into person values (1, 12);  #12insert into person values (1, 123); #123</code></pre><h2 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h2><p><strong>专门用来保存小数的</strong></p><pre><code class="hljs reasonml"><span class="hljs-constructor">FLOAT(<span class="hljs-params">m</span>, <span class="hljs-params">d</span>)</span>     <span class="hljs-number">4</span> 字节  单精度<span class="hljs-constructor">DOUBLE(<span class="hljs-params">m</span>, <span class="hljs-params">d</span>)</span>    <span class="hljs-number">8</span> 字节  双精度m总位数, d小数位数</code></pre><p><strong>注意点：float和double的区别</strong><br>占用存储空间大小不一样</p><p>默认保留的小数位数不同</p><pre><code>create table person(    id int,    weight FLOAT,    height DOUBLE);insert into person values (1, 1.12345678901234567890, 1.12345678901234567890);weight: 1.12346height: 1.1234567890123457</code></pre><p>保存数据的有效精度也不同</p><pre><code>create table person3(    id int,    weight FLOAT(20, 19),    height DOUBLE(20, 19));insert into person3 values (1, 1.12345678901234567890, 1.12345678901234567890);weight: 1.123456-8357467651000height: 1.123456789012345-7000</code></pre><p><strong>注意点：</strong><br>浮点类型是不准确的，所以在企业开发中千万不要使用浮点数来保存用户的准确(珍贵)信息(RMB)</p><h2 id="定点类型"><a href="#定点类型" class="headerlink" title="定点类型"></a>定点类型</h2><p><strong>也是用于存储小数的</strong></p><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">decimal</span><span class="hljs-params">(M, D)</span></span>m总位数, d小数位数</code></pre><p><strong>注意点：</strong><br><strong>定点类型的本质: 是将数据分为两个部分来存储,每个部分都是整数所以定点数不要滥用, 因为非常消耗资源</strong></p><pre><code>create table person4(    id int,    weight decimal(21, 20),    height decimal(21, 20));insert into person4 values (1, 1.12345678901234567890, 1.12345678901234567890);weight: 1.12345678901234567890height: 1.12345678901234567890</code></pre><h2 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h2><p><strong>专门用来存储字符的</strong></p><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">CHAR</span><span class="hljs-params">(size)</span></span>    <span class="hljs-number">0</span>-<span class="hljs-number">255</span>   字节    定长字符串<span class="hljs-function"><span class="hljs-title">VARCHAR</span><span class="hljs-params">(size)</span></span> <span class="hljs-number">0</span>-<span class="hljs-number">65535</span> 字节    变长字符串</code></pre><p><strong>注意点：</strong><br> char和varchar能够保存数据的容量不一样，char不会回收多余的字符,  要多少给多少<br> ，varchar会回收多余的字符, 用多少给多少</p><pre><code>通过    char(2)存储存储数据&#39;a&#39;, 存储的结果是&#39; a&#39;通过 varchar(2)存储存储数据&#39;a&#39;, 存储的结果是&#39;a&#39;</code></pre><p><strong>char超出设定范围会报错</strong></p><pre><code>create table person(    id int,    name1 char(2),    name2 varchar(2));insert into person values (1, &#39;a&#39;, &#39;b&#39;);insert into person values (1, &#39;12&#39;, &#39;34&#39;);insert into person values (1, &#39;abc&#39;, &#39;def&#39;); #只要超出申请的范围就会报错</code></pre><p><strong>注意点: 由于是字符类型, 所以传递值建议用单引号’’</strong><br><strong>注意点: VARCHAR理论上可以存储65535个字符, 但是实际会随着当前数据库的字符集改变</strong></p><pre><code>create table person3(    id int,    name1 char(255),    name2 varchar(65535))charset=utf8;Column length too big for column &#39;name2&#39; (max = 21845); use BLOB or TEXT instead65535 / 3 = 21845, 由于utf8一个字符占用3个字节, 所以varchar在utf8的表中最多只能存储21845个字符create table person3(    id int,    name1 char(255),    name2 varchar(65535))charset=gbk;Column length too big for column &#39;name2&#39; (max = 32767); use BLOB or TEXT instead65535 / 2 = 32767, 由于gbk一个字符占用2个字节,所以varchar在gbk的表中最多只能存储32767个字符</code></pre><p><strong>注意点: VARCHAR理论上可以存储65535个字符, 但是实际会随着当前数据库的字符集改变</strong></p><pre><code>65535 / 3 = 21845, 由于utf8一个字符占用3个字节,所以varchar在utf8的表中最多只能存储21845个字符65535 / 2 = 32767, 由于gbk一个字符占用2个字节,所以varchar在gbk的表中最多只能存储32767个字符</code></pre><p><strong>注意点: VARCHAR理论上可以存储65535个字符,但是实际会随着当前数据库的字符集改变</strong></p><h3 id="大文本类型"><a href="#大文本类型" class="headerlink" title="大文本类型"></a>大文本类型</h3><p><strong>MySQL中每一行存储的数据是有大小限制的, 每一行最多只能存储65534个字节</strong></p><pre><code>create table person(    #name1 char(3),    name2 varchar(21844) #在UTF8中相当于65535个字节)charset=utf8;# Row size too large. The maximum row size for the used table type, not counting BLOBs, is 65535. This includes storage overhead, check the manual. You have to change some columns to TEXT or BLOBs</code></pre><p><strong>使用大文本类型解决这个问题</strong></p><pre><code class="hljs angelscript">TINYTEXT   <span class="hljs-number">0</span><span class="hljs-number">-255</span>字节           短文本字符串TEXT       <span class="hljs-number">0</span><span class="hljs-number">-65535</span>字节         长文本数据MEDIUMTEXT <span class="hljs-number">0</span><span class="hljs-number">-16777215</span>字节      中等长度文本数据LONGTEXT   <span class="hljs-number">0</span><span class="hljs-number">-4294967295</span>字节    极大文本数据</code></pre><pre><code> create table person2(    name1 char(3),    name2 TEXT #不会报错, 因为没有超出显示, 实际只占用10个字节)charset=utf8;</code></pre><p><strong>注意点:<br>大文本类型在表中并不会实际占用所能保存的字节数,而是利用10个字节引用了实际保存数据的地址</strong></p><h2 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h2><p><strong>如果某个字段的取值只能是几个固定值中的一个,那么就可以使用枚举</strong></p><pre><code class="hljs crystal"><span class="hljs-class"><span class="hljs-keyword">enum</span>(值1, 值2, ...);</span></code></pre><pre><code>create table person(    id int,    gender enum(&#39;男&#39;, &#39;女&#39;, &#39;妖&#39;));insert into person values (1, &#39;火&#39;); #会报错insert into person values (1, &#39;男&#39;); #不会报错insert into person values (2, &#39;女&#39;); #不会报错insert into person values (3, &#39;妖&#39;); #不会报错</code></pre><p><strong>注意点:</strong></p><p>MySQL中的枚举类型底层都是使用整型来实现的,和其它编程语言不太一样的是,其它编程语言的枚举都是从0开始的, 而MySQL的枚举是从1开始的</p><p>由于MySQL的枚举底层是使用整型实现的,所以我们在赋值的时候除了可以赋值固定的几个值其中的一个意外我们还可以赋值对应的整数</p><pre><code>insert into person values (4, 1); #不会报错insert into person values (4, 4); #会报错</code></pre><h2 id="集合类型"><a href="#集合类型" class="headerlink" title="集合类型"></a>集合类型</h2><p><strong>如果某个字段的取值只能是几个固定值中的几个,那么就可以使用集合类型</strong></p><pre><code class="hljs routeros"><span class="hljs-builtin-name">set</span>(值1, 值2, <span class="hljs-built_in">..</span>.)</code></pre><pre><code>create table person(    id int,    hobby set(&#39;篮球&#39;,&#39;足球&#39;,&#39;高尔夫球&#39;,&#39;足浴&#39;));insert into person values (1, &#39;篮球,足球,高尔夫球&#39;); #不会报错insert into person values (1, &#39;橄榄球&#39;);  #会报错insert into person values (2, &#39;篮球&#39;); #不会报错  1insert into person values (3, &#39;足球&#39;); #不会报错  2insert into person values (4, &#39;高尔夫球&#39;); #不会报错  4insert into person values (5, &#39;足浴&#39;); #不会报错  8</code></pre><p><strong>注意点:MySQL的集合类型也是使用整型来实现的,MySQL的集合类型是按照2(n)的方式来实现的</strong></p><pre><code>2(0) = 12(1) = 22(2) = 42(3) = 8</code></pre><h2 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h2><p><strong>专门用来保存真假的</strong></p><pre><code>create table person(    id int,    flag boolean);insert into person values (1, &#39;男&#39;); #会报错insert into person values (1, true); #不会报错insert into person values (2, false); #不会报错</code></pre><p><strong>注意点:MySQL中的布尔类型也是使用整型来实现的,0就表示假,1就表示真底层的本质是因为MySQL是使用C/C++来实现的, 所以就是’非零即真’</strong></p><pre><code>insert into person values (3, 1); #不会报错insert into person values (4, 0); #不会报错insert into person values (5, 2); #不会报错</code></pre><h2 id="日期类型"><a href="#日期类型" class="headerlink" title="日期类型"></a>日期类型</h2><p><strong>专门用来保存时间的</strong></p><pre><code class="hljs css"><span class="hljs-selector-tag">DATE</span>       3字节   <span class="hljs-selector-tag">YYYY-MM-DD</span>          日期值<span class="hljs-selector-tag">TIME</span>       3字节   <span class="hljs-selector-tag">HH</span><span class="hljs-selector-pseudo">:MM</span><span class="hljs-selector-pseudo">:SS</span>            时间值或持续时间<span class="hljs-selector-tag">DATETIME</span>   8字节   <span class="hljs-selector-tag">YYYY-MM-DD</span> <span class="hljs-selector-tag">HH</span><span class="hljs-selector-pseudo">:MM</span><span class="hljs-selector-pseudo">:SS</span> 混合日期和时间值</code></pre><p><strong>注意点: 在存储时间的时候, 需要用单引号将时间括起来</strong></p><pre><code>create table person(    id int,    filed1 DATE,    filed2 TIME,    filed3 DATETIME);insert into person values (1, &#39;2020-02-02&#39;, &#39;14:18:23&#39;, &#39;2020-02-02 14:18:23&#39;);</code></pre>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《写作这回事》摘抄与感悟</title>
    <link href="/2020/10/05/%E3%80%8A%E5%86%99%E4%BD%9C%E8%BF%99%E5%9B%9E%E4%BA%8B%E3%80%8B%E6%91%98%E6%8A%84%E4%B8%8E%E6%84%9F%E6%82%9F/"/>
    <url>/2020/10/05/%E3%80%8A%E5%86%99%E4%BD%9C%E8%BF%99%E5%9B%9E%E4%BA%8B%E3%80%8B%E6%91%98%E6%8A%84%E4%B8%8E%E6%84%9F%E6%82%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="摘抄"><a href="#摘抄" class="headerlink" title="摘抄"></a>摘抄</h1><ul><li><p>”你写故事时，是在给自己讲故事，“ 他说，” 你修改时，主要工作就是拿掉不属于故事的内容“</p></li><li><p>我学到的最重要的一点就是，作家对角色的最初认识可能和读者一样是错误的。我紧接着又认识到，仅仅因为创作困难，不论是感情上的原因，还是因为想象力缺乏，就中途放弃一部作品，这样的做法不可取。人有时候就得硬着头皮上，哪怕力不从心，仿佛坐着铲屎，使不上劲。因为你干出来的活儿会可能还不错</p></li><li><p>开始是这样：把你的书桌摆到屋角，每次做下去开始写作时，都要提醒自己为什么不把书桌摆在房间正中。生活并非艺术创作的支撑，反之才对。</p></li><li><p>我的建议就是，你为了尽最大的能力写作，有必要建造自己的工具箱，然后增强肌肉力量，才有力气把箱子带在身边。你这样做，就不必在面对艰难任务时感到气馁，而是一把抓过适用的工具，立刻投入工作。</p></li><li><p>记住用词的第一条规矩是使用你想到的第一个词，只要这个词事宜并且生动即可。</p></li><li><p>界定对话做好的方式就是”某某说“。比如”他说“，”她说“，”比尔说“，”莫妮卡说“。</p></li><li><p>你也许已经可以把故事讲得很不错，相信读者看到”他说“就会知道他讲话的语气与动作——是慢是块，是愉快还是伤心。但你的读者也许还在沼泽里挣扎，甭管怎么说，扔给他一根绳索……但绝对没必要拿根九十英尺的钢索把他迎头打晕。</p></li><li><p>概括性句子打头，描述和支持性词句紧跟在后。这种结构要求作者必须理清思路，而且这种结构可以使作者避免游离主题</p></li><li><p>写小说越多，就越会发现，段落是自动形成的。你需要的正是这种效果。写作小说时，最好不必过多考虑何时另起一段。诀窍就是顺其自然</p></li><li><p>我坚持认为段落而非句子才是写作的基本单位——意思在段落中连贯起来，词语有了更多的意义，不再仅仅是单词。段落也体现了节奏的快慢。</p></li><li><p>你如果想成为作家，必须首先得做到两件事：多读，多写。据我所知别无捷径，哪个作家都干过这两件事。</p></li><li><p>糅和不同风格，是你形成个人风格之前的必经阶段，但杂糅不是凭空发生的。你必须广泛阅读。</p></li><li><p>天赋使得练习这回事完全失去了意义；你如果发现自己在做某件事上天赋异禀，会主动去做这件事（不管是什么事）</p></li><li><p>在我看来，短篇小说也罢长篇小说也罢，都是由三部分构成的：叙事，将故事从A点推至B点最终推至Z点，故事结束；描写，把读者带进现场；对话，通过具体言语赋予人物生命。</p></li><li><p>好描写始于所见清晰，终于落笔清晰，意象清新，词汇简单。</p></li><li><p>好小说的注重法则之一就是，你如果可以将某事表现出来，让读者看到，就绝不要明讲出来。</p></li><li><p>从问题主题思想开始写作，几乎注定写不出好小说。好小说总是从故事开始，发展出主题；从主题发展出而来的好故事很少。</p></li><li><p>你如果是为了快乐而做事，就可以永远做下去。</p></li></ul><h1 id="作者推荐书单"><a href="#作者推荐书单" class="headerlink" title="作者推荐书单"></a>作者推荐书单</h1><p>彼得•亚伯拉汉斯：《完美犯罪》</p><p>彼得•亚伯拉汉斯：《熄灯》</p><p>彼得•亚伯拉汉斯：《压降》（又译《窃子疑云》）</p><p>彼得•亚伯拉汉斯：《9号革命》</p><p>詹姆斯•阿奇：《家人亡故》</p><p>克斯滕•巴奇斯：《怪物狗的生活》</p><p>帕特•巴克：《新生》</p><p>帕特•巴克：《门上的眼睛》</p><p>帕特•巴克：《幽灵路》</p><p>理查德•博氏：《黑夜季节》</p><p>彼得•布朗纳：《入侵者》</p><p>保罗•博尔斯：《遮蔽的天空》</p><p>柯拉盖森•波尔：《玉米饼幕布》</p><p>比尔•布莱森：《林中散步》</p><p>克里斯多夫•巴克利：《感谢您吸烟》</p><p>雷蒙德•卡佛：《我打电话的地方》</p><p>迈克尔•查本：《狼人年轻时》</p><p>温莎•乔尔顿：《零纬度》</p><p>迈克尔•康纳利：《诗人》</p><p>约瑟夫•康拉德：《黑暗的心脏》</p><p>K.C. 康斯坦丁：《家庭观念》</p><p>唐•德里罗：《地下世界》</p><p>尼尔森•德米尔：《教堂》</p><p>尼尔森•德米尔：《黄金海岸》</p><p>查尔斯•狄更斯：《雾都孤儿》</p><p>斯蒂芬•道宾斯：《等闲杀戮》</p><p>斯蒂芬•道宾斯：《死女孩的教堂》</p><p>罗迪•道伊尔：《撞上门的女人》</p><p>斯丹利•埃尔金：《迪克•吉布森秀》</p><p>威廉•福克纳：《我弥留之际》</p><p>亚历克斯•嘉兰：《海滩》</p><p>伊丽莎白•乔治：《心怀鬼胎》</p><p>苔丝•格里森：《重力》</p><p>威廉•戈尔丁：《蝇王》</p><p>穆雷尔•格雷：《熔炉》</p><p>格雷厄姆•格林：《一支出卖的枪》</p><p>格雷厄姆•格林：《我们在哈瓦那的人》</p><p>大卫•哈尔伯斯坦姆：《五十年代》</p><p>彼得•哈米尔：《辛纳特拉何以重要》</p><p>托马斯•哈里斯：《汉尼拔》</p><p>肯特•哈鲁夫：《单声颂歌》</p><p>彼得•霍格：《冰雪迷案》</p><p>斯蒂芬•亨特：《白人坏小子》</p><p>大卫•伊格纳修斯：《开火伤人》</p><p>约翰•欧文：《寡居的一年》</p><p>格雷厄姆•乔伊斯：《牙齿仙子》</p><p>艾伦•贾德：《魔鬼的杰作》</p><p>罗杰•卡恩：《美梦成真》</p><p>玛丽•卡尔：《撒谎者俱乐部》</p><p>杰克•柯切姆：《生的权利》</p><p>塔碧莎•金：《幸存者》</p><p>塔碧莎•金：《水中天》（未出版）</p><p>芭芭拉•金索尔沃：《毒树圣经》</p><p>约翰•柯拉考尔：《挑战巅峰》</p><p>哈珀•李：《杀死一只知更鸟》</p><p>伯纳德•列夫科维奇：《我们的人》</p><p>本特利•利特尔：《被忽视的人》</p><p>诺尔曼•麦克利恩：《大河恋：作品集》</p><p>萨默塞特•毛姆：《月亮和六便士》</p><p>科马克•麦卡锡：《平原城市》</p><p>科马克•麦卡锡：《十字路口》</p><p>弗兰克•麦考特：《安吉拉的灰烬》</p><p>爱丽丝•麦克德莫特：《迷人比利》</p><p>杰克•麦克德维特：《远古海岸》</p><p>伊恩•麦克尤恩：《爱无可忍》</p><p>伊恩•麦克尤恩：《水泥花园》</p><p>拉里•麦克穆特里：《死人漫步》</p><p>拉里•麦克穆特里和戴安娜•奥萨纳：《契克和奈德》</p><p>沃特•米勒：《献给雷波维奇的圣歌》</p><p>乔伊丝•卡罗尔•欧茨：《行尸走肉》</p><p>蒂姆•奥布莱恩：《林中湖上》</p><p>斯图尔特•奥南：《超速女王》</p><p>迈克尔•翁达杰：《英国病人》</p><p>理查德•诺斯•帕特森：《无处安身》</p><p>理查德•普莱斯：《自由国度》</p><p>安妮•普劳克斯：《怀俄明故事集》</p><p>安妮•普劳克斯：《航运新闻》</p><p>安娜•昆德伦：《真理》</p><p>露丝•伦德尔：《见到你真好》</p><p>弗兰克•罗宾森：《等待》</p><p>J•K. 罗琳：《哈利•波特与密室》</p><p>J•K. 罗琳：《哈利•波特与阿兹卡班的囚徒》</p><p>J•K. 罗琳：《哈利•波特与魔法石》</p><p>理查德•鲁索：《莫霍克》</p><p>约翰•伯恩海姆•施瓦兹：《救赎之路》</p><p>维克兰•塞斯：《如意郎君》</p><p>欧文•肖：《幼狮》</p><p>理查德•斯罗特金：《弹坑》</p><p>蒂尼夏•史密斯：《魔术师》</p><p>斯科特•斯宾塞：《黑衣人》</p><p>华莱士•斯台戈纳：《乔•希尔》</p><p>多娜•塔特：《校园秘史》</p><p>安•泰勒：《补丁行星》</p><p>库尔特•冯内古特：《咒语》</p><p>伊夫林•沃：《故园风雨后》</p><p>唐纳德•韦斯特雷克：《斧》</p><h1 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;作者以桌子上的一块红布与笼子里背上写着蓝色8的兔子把我拉到了1997年他的身边，我仿佛穿越了。这是我第一次感受到文字的奥妙与神奇之处，写作已经深深吸引住了我。读到后面关于禁止使用被动语态，激动的我写下了有史以来第一段感觉还不错的这段文字。我走到了河边，看！河上有一艘船，大概有一辆公交车那么大，船头站着一个和尚，手执一个发着绿光的魔法棒。</p><p>写作最重要的就是要对自己所写的东西自信并热爱它，能够让自己和读者带入其中，把每个角色变成鲜活的生命，要真实真诚。</p>]]></content>
    
    
    <categories>
      
      <category>读书</category>
      
      <category>写作</category>
      
    </categories>
    
    
    <tags>
      
      <tag>斯蒂芬·金</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL数据库(一) —— 增删改查</title>
    <link href="/2020/10/04/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93(%E4%B8%80)/"/>
    <url>/2020/10/04/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93(%E4%B8%80)/</url>
    
    <content type="html"><![CDATA[<h1 id="数据库增删改查"><a href="#数据库增删改查" class="headerlink" title="数据库增删改查"></a><strong>数据库增删改查</strong></h1><h2 id="新建数据库"><a href="#新建数据库" class="headerlink" title="新建数据库"></a><strong>新建数据库</strong></h2><pre><code>create database if not exists 数据库名称 charset=字符集;</code></pre><h2 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a><strong>删除数据库</strong></h2><pre><code>drop database if exists 数据库名称;</code></pre><h2 id="修改数据库"><a href="#修改数据库" class="headerlink" title="修改数据库"></a><strong>修改数据库</strong></h2><pre><code>alter database 数据库名称 charset=字符集;</code></pre><h2 id="查看数据库"><a href="#查看数据库" class="headerlink" title="查看数据库"></a><strong>查看数据库</strong></h2><pre><code>show create database 数据库名称;show databases;</code></pre><h1 id="表增删改查"><a href="#表增删改查" class="headerlink" title="表增删改查"></a><strong>表增删改查</strong></h1><p><strong>注意点:<br>在对数据库的表进行操作的时候(增删改查), 都必须先告诉MySQL我们要操作的是哪一个数据库</strong></p><pre><code>use 数据库名称;</code></pre><h2 id="查看数据库中有哪些表"><a href="#查看数据库中有哪些表" class="headerlink" title="查看数据库中有哪些表"></a><strong>查看数据库中有哪些表</strong></h2><pre><code>show tables;</code></pre><h2 id="查看指定表的结构"><a href="#查看指定表的结构" class="headerlink" title="查看指定表的结构"></a><strong>查看指定表的结构</strong></h2><pre><code>desc 表名;</code></pre><h2 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a><strong>创建表</strong></h2><pre><code>create table if not exists 表名(  字段名称 数据类型,  字段名称 数据类型,);</code></pre><p><strong>注意点: 以上代码创建表, 没有就会创建一个新的, 有就会自动跳过</strong></p><h2 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a><strong>删除表</strong></h2><pre><code>drop table if exists 表名;</code></pre><p><strong>注意点: 以上语句, 如果需要删除的表存在, 那么就直接删除, 如果不存在就跳过</strong></p><h2 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a><strong>修改表</strong></h2><h3 id="修改表名"><a href="#修改表名" class="headerlink" title="修改表名"></a><strong>修改表名</strong></h3><pre><code>rename table 原始名称 to 新的名称;</code></pre><h3 id="添加字段"><a href="#添加字段" class="headerlink" title="添加字段"></a><strong>添加字段</strong></h3><pre><code>alter table 表名 add 新增字段名称 新增字段数据类型;</code></pre><p><strong>注意点:</strong> </p><p><strong>默认情况下会将新增的字段放到原有字段的后面</strong></p><pre><code>alter table 表名 add 字段名 数据类型 first;</code></pre><p><strong>我们可以通过指定first将新增的字段放到原有字段的前面</strong></p><pre><code>alter table 表名 add 字段名 数据类型 after 字段名;</code></pre><p><strong>我们可以通过after指定将新增的字段放到哪个字段的后面</strong></p><h3 id="删除字段"><a href="#删除字段" class="headerlink" title="删除字段"></a><strong>删除字段</strong></h3><pre><code>alter table 表名 drop 字段名称;</code></pre><h3 id="修改字段"><a href="#修改字段" class="headerlink" title="修改字段"></a><strong>修改字段</strong></h3><h4 id="修改字段的数据类型"><a href="#修改字段的数据类型" class="headerlink" title="修改字段的数据类型"></a><strong>修改字段的数据类型</strong></h4><pre><code>alter table 表名 modify 需要修改的字段名称 新的数据类型</code></pre><h4 id="修改字段的名称和数据类型"><a href="#修改字段的名称和数据类型" class="headerlink" title="修改字段的名称和数据类型"></a><strong>修改字段的名称和数据类型</strong></h4><pre><code>alter table 表名 change 原始字段名称 新的字段名称 新的数据类型;</code></pre><h1 id="数据增删改查"><a href="#数据增删改查" class="headerlink" title="数据增删改查"></a><strong>数据增删改查</strong></h1><h2 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a><strong>插入数据</strong></h2><pre><code>insert into 表名 (字段名称1, 字段名称2) values (值1, 值2);</code></pre><p><strong>注意点:</strong> </p><p><strong>在插入数据的时候指定的字段名称的顺序不用和表中的字段名称的顺序一致<br>在插入数据的时候指定的取值顺序必须和指定的字段名称顺序一致<br>如果插入数据时指定的取值顺序和表中的字段顺序是一致的, 那么可以不指定字段名称</strong></p><pre><code> insert into  stu values (值1, 值2), (值1, 值2);</code></pre><p><strong>注意点: 我们可以通过values同时插入多条数据</strong></p><h2 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a><strong>更新数据</strong></h2><pre><code>update 表名 set 字段名称=值 [where 条件];</code></pre><p><strong>注意点:</strong></p><p><strong>如果在更新数据的时候没有指定条件, 那么就会更新整张表中的数据<br>如果在更新数据的时候指定了条件, 那么只会更新满足条件的数据<br>在指定条件的时候, 我们可以通过AND来指定多个条件, AND<br>在指定条件的时候, 我们可以通过OR来指定多个条件, OR<br>在更新数据的时候是可以同时更新多个字段的,字段之间用逗号隔开</strong></p><h2 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a><strong>查询数据</strong></h2><p><strong>注意点:</strong> </p><p><strong>以下方式会将表中所有的数据都查询出来, 所以性能比较差, 不能查询特定字段的值</strong></p><pre><code>select * from 表名;</code></pre><p><strong>以下才是查询数据完整的写法</strong></p><pre><code>select 字段名称1, 字段名称2 from 表名 where 条件;</code></pre><p><strong>查询特定字段的数据</strong></p><pre><code>select 字段名称1 from 表名;</code></pre><p><strong>where支持的运算符</strong></p><ul><li>=、!=、&lt;&gt;、&lt;、&lt;=、&gt;、&gt;=；</li><li>IN(X,Y)；固定的范围值</li><li>BETWEEN X AND Y；值在什么范围</li><li>IS NULL；（为空） </li><li>IS NOT NULL；（不为空）</li><li>AND；与</li><li>OR；或</li><li>NOT；非</li><li>LIKE: 模糊查询</li></ul><h2 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a><strong>删除数据</strong></h2><pre><code>delete from 表名 where 条件;</code></pre><p><strong>删除所有的数据</strong></p><pre><code>delete from 表名;</code></pre><h1 id="MySQL存储引擎"><a href="#MySQL存储引擎" class="headerlink" title="MySQL存储引擎"></a><strong>MySQL存储引擎</strong></h1><ul><li><h2 id="MySQL中的三种存储引擎"><a href="#MySQL中的三种存储引擎" class="headerlink" title="MySQL中的三种存储引擎"></a><strong>MySQL中的三种存储引擎</strong></h2><ul><li>MyISAM: 安全性低, 但不支持事务和外键, 适合频繁插入和查询的应用</li><li>InnoDB(默认): 安全性高, 支持事务和外键, 适合对安全性, 数据完整性要求较高的应用</li><li>Memory: 访问速度极快, 但不会永久存储数据, 适合对读写速度要求较高的应用</li></ul></li></ul><p>创建时指定存储引擎</p><pre><code>create table if not exists 表名(          字段名称 数据类型,          字段名称 数据类型,        )engine=引擎名称;</code></pre><h3 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a><strong>InnoDB</strong></h3><p>如果表的存储引擎是InnoDB, 那么只要创建表就会自动创建一个文件, 这个文件就保存了这张表的结构, 如果往InnoDB的表中存储数据, 那么数据会被存储到ibdata1的文件中, 如果存储的数据比较多, 那么系统会自动再创建ibdata2, ibdata3, …文件</p><h3 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a><strong>MyISAM</strong></h3><p>如果表的存储引擎是MyISAM, 那么只要创建表就会自动创建三个文件</p><ul><li>.sdi这个文件就保存了这张表的结构</li><li>.MYD这个文件就保存了这张表中存储的数据</li><li>.MYI这个文件就保存了这张表中的索引</li></ul><h3 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a><strong>Memory</strong></h3><p>如果表的存储引擎是Memory, 那么只要创建表就会自动创建一个文件,这个文件就保存了这张表的结构<br><strong>注意点: 如果表的存储引擎是Memory, 那么就不会像InnoDB/MyISAM将数据保存到文件中了, 而是直接保存到内存中</strong></p><h2 id="修改存储引擎"><a href="#修改存储引擎" class="headerlink" title="修改存储引擎"></a><strong>修改存储引擎</strong></h2><pre><code>alter table 表名 engine=引擎名称;</code></pre>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
